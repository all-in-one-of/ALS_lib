{"body": [{"indent": 0, "text": ["FLIP Solver"], "type": "title", "level": 0}, {"indent": 0, "type": "summary", "text": ["Evolves an object as a FLIP fluid object."]}, {"indent": 0, "type": "para", "text": ["The FLIP Solver DOP evolves an object dynamically as a particle fluid."]}, {"indent": 0, "type": "para", "text": ["A FLIP solver is a type of hybrid between a particle based and volume\nbased fluid simulations.  All fluid data is stored in the particles and\nonly particles need to persist frame to frame, ensuring no unwanted\nmixing or loss of fluid can occur.  However, the pressure projection\nstep is done on a volume that is created just in time. The fluid is\nrepresented by particles with their ", {"text": ["pscale"], "type": "code"}, ", and can be moved around\nwith POP and DOP forces."]}, {"indent": 0, "type": "para", "text": ["When FLIP fluids are solved, a temporary velocity field is made. The\nparticle velocities are transferred to this grid and the grid is used to\nperform the fluid projection. This is what prevents the particles from\nall going on top of each other and start moving in similar directions."]}, {"body": [{"body": [{"indent": 4, "type": "para", "text": ["Advanced users can also add volume velocity forces at this stage as\n    well."]}], "indent": 0, "role": "item", "type": "note"}], "container": true, "role": "item_group", "type": "note_group"}, {"indent": 0, "type": "para", "text": ["FLIP fluids are faster than SPH fluids, if you don\u2019t need to substep the\nFLIP fluid. If you need to substep the FLIP fluid because of fast moving\ncolliders, you may find SPH just as a fast or faster. FLIP fluids are\nalso useful because particles can be placed on top of each other without\ndestabilizing the system. SPH tends to blow up if you move particles too\nclose."]}, {"indent": 0, "type": "para", "text": ["The advantage of the FLIP Solver is that you run with only a few time\nsteps per frame while SPH requires anywhere from 7 to 20 time steps or\nmore per frame to stabilize. FLIP utilizes a few grids (volume fields)\nto help tame the instantaneous impulses that can arise in a fluid sim."]}, {"indent": 0, "type": "para", "text": ["Various fields are used to tame the FLIP Solver so that you can run far\nfewer points at far fewer time steps and the inter-spacing between\nparticles can be random. You can introduce new particles at any time\nwith little to no consequence. This opens up so many new work flows in\nPOPs that were simply not possible with SPH. For example, introducing\nsplash particles with their own property attributes is now possible."]}, {"indent": 0, "type": "para", "text": ["The FLIP Solver contains an embedded POP Solver, enabling the use of\nPOP forces by plugging them into the ", {"text": ["Particle Velocity"], "type": "ui"}, " input or\ninline below any ", {"_hs_sc": true, "text": ["Source Volume"], "value": "/nodes/dop/sourcevolume", "fullpath": "/nodes/dop/sourcevolume", "scheme": "Node", "type": "link"}, " emitters.  Any\nPOP node that updates the ", {"text": ["v"], "type": "code"}, ", ", {"text": ["targetv"], "type": "code"}, ", or ", {"text": ["force"], "type": "code"}, " attribute can\nbe used, as well as others that affect attributes like particle color\nor age.  The POP Solver also supports other particle behavior such\nas aging and reaping particles."]}, {"body": [{"indent": 0, "type": "para", "text": ["The ", {"text": ["Velocity Transfer"], "type": "ui"}, " parameter allows you to choose between the default ", {"text": ["Splashy Kernel"], "type": "ui"}, " and a ", {"text": ["Swirly Kernel"], "type": "ui"}, ".  The ", {"text": ["Splashy Kernel"], "type": "ui"}, " is typically used for high energy, noisy large FLIP simulations like rivers or oceans, where the surface from FLIP noise isn\u2019t a problem. The ", {"text": ["Swirly Kernel"], "type": "ui"}, " is typically used for high vorticity simulations where you need to reduce surface noise as much as possible while still retaining the swirling nature of the simulation. For example, for small scale fluids where surface noise can be really distracting or for lava type simulations. "]}, {"body": [{"body": [{"indent": 4, "type": "para", "text": ["The ", {"text": ["Splashy Kernel"], "type": "ui"}, " corresponds to the ", {"text": ["FLIP/PIC"], "type": "ui"}, " method of velocity transfer, while the ", {"text": ["Swirly Kernel"], "type": "ui"}, " is implemented with the newer ", {"text": ["APIC"], "type": "ui"}, " method.  All of the ", {"_hs_sc": true, "text": ["Viscous shelf tools"], "value": "/shelf/viscousfluids", "fullpath": "/shelf/viscousfluids", "scheme": null, "type": "link"}, " use the Swirly Kernel."]}], "indent": 0, "role": "item", "type": "note", "text": [" "]}], "container": true, "role": "item_group", "type": "note_group"}], "indent": 0, "level": 2, "text": ["Splashy vs Swirly Kernel"], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "text": ["For emitting large numbers of particles, the ", {"_hs_sc": true, "text": ["Source Volume\nDOP"], "value": "/nodes/dop/sourcevolume", "fullpath": "/nodes/dop/sourcevolume", "scheme": "Node", "type": "link"}, " can be much faster than the ", {"_hs_sc": true, "text": ["Particle Fluid\nEmitter DOP"], "value": "/nodes/dop/particlefluidemitter", "fullpath": "/nodes/dop/particlefluidemitter", "scheme": "Node", "type": "link"}, ". You can set up surface\nemission using the ", {"_hs_sc": true, "text": ["Source From Surface"], "value": "/shelf/sourcefromsurface", "fullpath": "/shelf/sourcefromsurface", "scheme": null, "type": "link"}, " shelf\ntool or volumetric emission using ", {"_hs_sc": true, "text": ["Source From\nVolume"], "value": "/shelf/sourcefromvolume", "fullpath": "/shelf/sourcefromvolume", "scheme": null, "type": "link"}, " from the ", {"text": ["Populate Containers"], "type": "ui"}, " shelf."]}, {"indent": 0, "type": "para", "text": ["If your scene is modeled in units besides meters, be sure to set\n", {"text": ["Spatial Scale"], "type": "ui"}, " correctly. Otherwise the FLIP Solver will adjust\nparticle positions with more accuracy than required for the scene scale.\nThe resulting performance degradation mostly affects ", {"text": ["Reseeding"], "type": "ui"}, " and\nthe ", {"text": ["Move Outside Collision"], "type": "ui"}, " collision detection method."]}, {"indent": 0, "type": "para", "text": ["Turning off ", {"text": ["Use Preconditioner"], "type": "ui"}, " might improve solve performance if\nsimulating on a system with multiple CPU cores."]}, {"indent": 0, "type": "para", "text": ["Use the Performance Monitor to detect bottlenecks in your FLIP\nsimulations.  In general the FLIP Solver should consume most of the\nsolve time for a typical DOP Network.  If emitting particles is taking a\nlarge amount of time, consider using ", {"_hs_sc": true, "text": ["Source\nVolume"], "value": "/nodes/dop/sourcevolume", "fullpath": "/nodes/dop/sourcevolume", "scheme": "Node", "type": "link"}, " emission as described above and possibly\neven caching the points created by the corresponding ", {"_hs_sc": true, "text": ["Fluid Source\nSOP"], "value": "/nodes/sop/fluidsource", "fullpath": "/nodes/sop/fluidsource", "scheme": "Node", "type": "link"}, "."]}, {"indent": 0, "type": "para", "text": ["If writing out large FLIP simulations to disk using the ", {"_hs_sc": true, "text": ["Dop I/O\nSOP"], "value": "/nodes/sop/dopio", "fullpath": "/nodes/sop/dopio", "scheme": "Node", "type": "link"}, ", enable ", {"text": ["Save In Background"], "type": "ui"}, " to allow the\nsimulation to continue while the disk writes occur in the background.\nDeleting any unneeded attributes using the Compression tab will also\nsave disk space and write time."]}, {"indent": 0, "type": "para", "text": ["Enable ", {"text": ["Reseeding"], "type": "ui"}, " to help preserve surface detail, possibly\nincreasing ", {"text": ["Surface Oversampling"], "type": "ui"}, " to 2 or more."]}, {"indent": 0, "type": "para", "text": ["The ", {"text": ["Velocity"], "type": "ui"}, " fields are heavily blurred and thresholded for large\nchanges in velocity, which is completely tunable if the FLIP solver\nappears to be exploding. The ", {"text": ["Pressure"], "type": "ui"}, " field is used to monitor any\nareas of very high and very low pressure and then the fluid sim can\ncompensate the ", {"text": ["Velocity"], "type": "ui"}, " fields which then push the points around.\nThis is where the controls for cavitation, entrapped air, and fluid\nescape are managed to a great extent. The ", {"text": ["Surface"], "type": "ui"}, " field can be used\nto test the past if some particles have flown far too far off the\nsurface and then constrained back."]}, {"indent": 0, "type": "para", "text": ["Increasing the ", {"text": ["Particle Separation"], "type": "ui"}, " will lower the resolution, which will make your simulation faster to process."]}, {"indent": 0, "type": "para", "text": ["Usually you will not need to increase ", {"text": ["Substeps"], "type": "ui"}, " with FLIP. However, you may want to increase this value when simulating fast moving fluid that collides with other objects. You can also increase ", {"text": ["Substeps"], "type": "ui"}, " to improve the look of slow moving viscous fluid. Surface tension is an exception where substepping is likely required to maintain stability."]}, {"indent": 0, "type": "para", "text": ["You can vary amounts of stickiness to different objects, by building your own sticky field. The ", {"_hs_sc": true, "text": ["Fluid Source"], "value": "/nodes/sop/fluidsource", "fullpath": "/nodes/sop/fluidsource", "scheme": "Node", "type": "link"}, " can be used to take a point attribute like ", {"text": ["sticky"], "type": "code"}, " and make it a varying volume where you want stickiness to occur. Then, in the solver, you can use this field as the control field for the ", {"text": ["Stick On Collision"], "type": "ui"}, " function on the ", {"text": ["Collisions"], "type": "ui"}, " tab of the solver."]}, {"body": [{"body": [{"body": [{"indent": 16, "type": "para", "text": ["This is different from just turning on ", {"text": ["Show Collision Guide Geometry"], "type": "ui"}, " on the collision object. The collision fields on the ", {"_hs_sc": true, "text": ["FLIP Object"], "value": "/nodes/dop/flipobject", "fullpath": "/nodes/dop/flipobject", "scheme": "Node", "type": "link"}, " are the result of sampling from that volume and building a velocity field from object transforms or point velocities."]}], "indent": 8, "role": "item", "type": "note"}], "container": true, "role": "item_group", "type": "note_group"}], "indent": 0, "type": "para", "text": ["A good debugging rule of thumb for FLIP when seeing unexpected collision behavior is to immediately enable the ", {"text": ["Collision"], "type": "ui"}, " and ", {"text": ["Collision Velocity"], "type": "ui"}, " visualization on the ", {"_hs_sc": true, "text": ["FLIP Object"], "value": "/nodes/dop/flipobject", "fullpath": "/nodes/dop/flipobject", "scheme": "Node", "type": "link"}, ", so you can see exactly what the solver is seeing for collisions."]}, {"indent": 0, "type": "para", "text": ["Turning ", {"text": ["Reseed Particles"], "type": "ui"}, " off and having the ", {"text": ["Jitter Scale"], "type": "ui"}, " set to 0 gives a uniform-spaced grid of particles. This is generally not recommended, because you won\u2019t end up filling the voxels as effectively as with jittered points, and as they move around you\u2019ll get an uneven distribution due to numerical error, especially with ", {"text": ["Reseed Particles"], "type": "ui"}, " turned off."]}, {"body": [{"indent": 0, "type": "para", "text": ["Accurate velocities for moving collision objects are extremely important for\nfluid simulations in general, but particularly for FLIP. Incorrect collision\nvelocities can lead to less dynamic splashes or fluid leaking through\ngeometry.  For DOPs to calculate accurate collision velocities with moving or\ndeforming DOP objects, the  ", {"_hs_sc": true, "text": ["DOP network"], "value": "/nodes/obj/dopnet", "fullpath": "/nodes/obj/dopnet", "scheme": "Node", "type": "link"}, " must have ", {"text": ["Cache\nSimulation"], "type": "ui"}, " enabled. However, with very large FLIP simulations, the FLIP\nobject data for a single timestep might not fit in cache memory.  In this\ncase, disable ", {"text": ["Allow Caching"], "type": "ui"}, " on the ", {"_hs_sc": true, "text": ["FLIP Object"], "value": "/nodes/dop/flipobject", "fullpath": "/nodes/dop/flipobject", "scheme": "Node", "type": "link"}, " to\nremove the FLIP data from the cache, while still caching the collision \nobjects."]}, {"indent": 0, "type": "para", "text": ["Many FLIP simulations use 2 or more substeps.  For deforming collision\nobjects, make sure that the input geometry properly interpolate to subframes. \nThe ", {"_hs_sc": true, "text": ["Collision Source"], "value": "/nodes/sop/collisionsource", "fullpath": "/nodes/sop/collisionsource", "scheme": "Node", "type": "link"}, " SOP handles interpolating the\ngeometry and creating VDB Signed Distance volumes that can be used with FLIP.\nUse the ", {"_hs_sc": true, "text": ["Deforming Object"], "value": "/shelf/deformingobject", "fullpath": "/shelf/deformingobject", "scheme": null, "type": "link"}, " shelf tool to set up deforming\ngeometry as a FLIP collision object."]}, {"indent": 0, "type": "para", "text": ["Another option for adding collision objects to fluid simulations was the \n", {"_hs_sc": true, "text": ["Collide With Object"], "value": "/shelf/collidewithobjects", "fullpath": "/shelf/collidewithobjects", "scheme": null, "type": "link"}, " shelf tool, which adds\ncollision volumes directly to the simulation using the\n", {"_hs_sc": true, "text": ["Source Volume"], "value": "/nodes/dop/sourcevolume", "fullpath": "/nodes/dop/sourcevolume", "scheme": "Node", "type": "link"}, " DOP. However, as of Houdini 14, this\noption is deprecated and not recommended.  Instead use the the\n", {"_hs_sc": true, "text": ["Deforming Object"], "value": "/shelf/deformingobject", "fullpath": "/shelf/deformingobject", "scheme": null, "type": "link"}, " shelf tool."]}, {"body": [{"body": [{"indent": 4, "type": "para", "text": ["If using ", {"text": ["Source Volume"], "type": "ui"}, " based collisions, you ", {"text": ["must"], "type": "em"}, " use the\n    ", {"text": ["Move Outside Collision"], "type": "ui"}, " method for particle collisions, because the ", {"text": ["Particle"], "type": "ui"}, "\n    method only works when a collision is represented by an actual DOP object."]}], "indent": 0, "role": "item", "type": "note"}, {"body": [{"indent": 4, "type": "para", "text": ["The default velocity scale for Source Volume is 1.5, which will cause\n    larger splashes by default, but for moving containers this should be\n    set to 1."]}], "indent": 0, "role": "item", "type": "note"}], "container": true, "role": "item_group", "type": "note_group"}, {"indent": 0, "type": "para", "text": ["In some cases, especially with thin collision objects, the FLIP Solver\nmay not resolve the collision properly when simulating at relatively low\nresolutions. Enabling ", {"text": ["Collision Separation"], "type": "ui"}, " on the ", {"_hs_sc": true, "text": ["FLIP\nObject"], "value": "/nodes/dop/flipobject", "fullpath": "/nodes/dop/flipobject", "scheme": "Node", "type": "link"}, " and setting this value to the ", {"text": ["Particle\nSeparation"], "type": "ui"}, " or smaller will create a higher-resolution collision field\nthat will help the solver resolve the collision better.  With very thin\nobjects you may even need to create proxy collision geometry that\ngenerates a thicker SDF."]}, {"indent": 0, "type": "para", "text": [{"text": ["Move Outside Collision"], "type": "ui"}, " is the fastest collision handling method and provides\nthe smoothest splashes, however it is not as accurate with fast-moving collision geometry.\nIt is also the only collision method that works with ", {"text": ["Source Volume"], "type": "ui"}, " based collisions."]}], "indent": 0, "level": 3, "text": ["Collision Tips"], "container": true, "type": "h", "id": null}], "indent": 0, "level": 2, "text": ["Tips"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["A scaling factor for time inside this solver. ", {"text": ["1"], "type": "code"}, " is normal speed, greater than ", {"text": ["1"], "type": "code"}, " makes the FLIP simulation appear speeded up, less than ", {"text": ["1"], "type": "code"}, " makes the simulation appear to be in slow motion."]}, {"indent": 4, "type": "para", "text": ["You can use expression functions such as ", {"_hs_sc": true, "text": "doptime()", "value": "/expressions/doptime", "fullpath": "/expressions/doptime", "scheme": "Exp", "type": "link"}, ", ", {"_hs_sc": true, "text": "dopframe()", "value": "/expressions/dopframe", "fullpath": "/expressions/dopframe", "scheme": "Exp", "type": "link"}, ",", {"_hs_sc": true, "text": "dopsttot()", "value": "/expressions/dopsttot", "fullpath": "/expressions/dopsttot", "scheme": "Exp", "type": "link"}, ", and ", {"_hs_sc": true, "text": "dopttost()", "value": "/expressions/dopttost", "fullpath": "/expressions/dopttost", "scheme": "Exp", "type": "link"}, " to convert between global times and simulation times."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["Changing the ", {"text": ["Timescale"], "type": "ui"}, " only affects the timestep of the simulation. If adding velocities calculated in SOPs to the simulation for collisions or pumps with the ", {"_hs_sc": true, "text": ["Source Volume DOP"], "value": "/nodes/dop/sourcevolume", "fullpath": "/nodes/dop/sourcevolume", "scheme": "Node", "type": "link"}, ", scale the incoming velocities by ", {"text": ["1 / Timescale"], "type": "code"}, " to match the timestep of the simulation."]}], "indent": 4, "role": "item", "type": "note"}], "container": true, "role": "item_group", "type": "note_group"}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Timescale"]}, {"body": [{"indent": 4, "type": "para", "text": ["The FLIP solver will always enforce this minimum number of substeps."]}, {"indent": 4, "type": "para", "text": ["This should only rarely need to be changed."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Min Substeps"]}, {"body": [{"indent": 4, "type": "para", "text": ["The FLIP solver will not break the simulation down in to more\n    substeps than this value."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Max Substeps"]}, {"body": [{"indent": 4, "type": "para", "text": ["The CFL condition is a factor used to automatically determine what\n    size substep the scene requires. The idea is to control the distance\n    that a particle in the particle fluid object can travel in a given\n    substep."]}, {"indent": 4, "type": "para", "text": ["For example, when this parameter is set to 0.5, the solver will set\n    the length of each substep such that no particle travels more than\n    50% of its particle separation in a given substep."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["CFL Condition"]}, {"body": [{"indent": 4, "type": "para", "text": ["The CFL condition for particle advection.  This can be set lower\n    than the CFL condition for the entire solver, as it only affects the\n    accuracy of particle advection in the velocity field."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Particle Advection CFL"]}, {"body": [{"indent": 4, "type": "para", "text": ["Alway use substeps that divide up the frame by ", {"text": ["Max Substeps"], "type": "ui"}, ".  For example,\n    if ", {"text": ["Max Substeps"], "type": "ui"}, " is set to 4, but the ", {"text": ["CFL Condition"], "type": "ui"}, " only requires 3 substeps,\n    the solver will take frame steps of 0.25, 0.5, and 0.25.  This option can be useful for\n    re-using input geometry that has been cached to file at increments of 1/", {"text": ["Max Substeps"], "type": "ui"}, "."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Quantize to Max Substeps"]}], "container": true, "role": "item_group", "type": "parameters_item_group"}], "indent": 0, "level": 2, "text": ["Substeps"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Standard DOP forces, such as gravity from a ", {"_hs_sc": true, "text": ["Gravity\n    DOP"], "value": "/nodes/dop/gravity", "fullpath": "/nodes/dop/gravity", "scheme": "Node", "type": "link"}, ", will be applied to the particles."]}, {"indent": 4, "type": "para", "text": ["This would only be turned off if you are combining a FLIP solver as\n    part of a larger solver system."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Apply External Forces"]}, {"body": [{"indent": 4, "type": "para", "text": ["If enabled, this attribute will disable the volume forces wherever\n    it is 1 on the particles, and enable it when where it is 0.  Ie,\n    particles with this attribute at 1 will fly ballistically with no\n    reference to other particles. However, their motion will still\n    affect other particles which have volume forces."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Force Override"]}, {"body": [{"indent": 4, "type": "para", "text": ["Depending on the values of the ", {"text": ["Particle Radius Scale"], "type": "ui"}, " and the\n    volume ", {"text": ["Grid Scale"], "type": "ui"}, " on the ", {"_hs_sc": true, "text": ["FLIP Object DOP"], "value": "/nodes/dop/flipobject", "fullpath": "/nodes/dop/flipobject", "scheme": "Node", "type": "link"}, ",\n    individual particles can become under-resolved on the grid and\n    \"disappear\" from the pressure solve.  This parameter controls how\n    the solver treats such particles:"]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["Make no attempt to detect under-resolved particles."]}], "indent": 4, "type": "dt", "text": ["No Detection"]}, {"body": [{"indent": 8, "type": "para", "text": ["Set a float-valued ", {"text": ["underresolved"], "type": "code"}, " attribute on each particle\n        that indicates the amount it is under-resolved."]}], "indent": 4, "type": "dt", "text": ["Detect Only"]}, {"body": [{"indent": 8, "type": "para", "text": ["Set the ", {"text": ["underresolved"], "type": "code"}, " attribute and combine it with any\n        specified ", {"text": ["Force Override"], "type": "ui"}, " attribute to determine whether the\n        particle should be treated ballistically or as a fluid."]}], "indent": 4, "type": "dt", "text": ["Treat as Ballistic"]}, {"body": [{"indent": 8, "type": "para", "text": ["Use the extrapolated fluid velocity unless a particle is\n        outside the range of valid extrapolated values as specified by \n        ", {"text": ["Max Cells to Extrapolate"], "type": "ui"}, ". For particles outside the valid\n        range, this setting is the same as ", {"text": ["Treat as Ballistic"], "type": "ui"}, ". This will reduce stringiness in splashes."]}], "indent": 4, "type": "dt", "text": ["Use Extrapolated Velocity"]}, {"body": [{"indent": 8, "type": "para", "text": ["Kill any fully under-resolved particles."]}], "indent": 4, "type": "dt", "text": ["Kill"]}], "container": true, "type": "dt_group"}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["If the ", {"text": ["Particle Radius Scale"], "type": "ui"}, " / ", {"text": ["Grid Scale"], "type": "ui"}, " >= sqrt(3) /\n        2, then particles will never be under-resolved."]}], "indent": 4, "role": "item", "type": "note"}], "container": true, "role": "item_group", "type": "note_group"}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Under-Resolved Particles"]}, {"body": [{"indent": 4, "type": "para", "text": ["Controls handling of collisions between particles and other objects."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["Do not perform particle collision detection.  Particles will\n        only avoid collisions as a result of the pressure solve, but due\n        to numerical error can possibly end up inside collision objects."]}], "indent": 4, "type": "dt", "text": ["None"]}, {"body": [{"indent": 8, "type": "para", "text": ["Perform particle collision detection, including Feedback between\n        particles and other simulated objects. This collision method\n        also supports friction and bounce.  It is the most accurate, but\n        slowest collision method."]}], "indent": 4, "type": "dt", "text": ["Particle"]}, {"body": [{"indent": 8, "type": "para", "text": ["Perform collision detection by moving particles outside any\n        collision objects.  This is faster than the ", {"text": ["Particle"], "type": "ui"}, " method,\n        but not as accurate for thin or fast-moving objects."]}], "indent": 4, "type": "dt", "text": ["Move Outside Collision"]}], "container": true, "type": "dt_group"}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Collision Detection"]}, {"body": [{"indent": 8, "type": "para", "text": ["Kill any particles that become stuck inside the collision SDF (in local minima) when using ", {"text": ["Move Outside Collision"], "type": "ui"}, " collision handling."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Kill Unmoveable Particles"]}], "container": true, "role": "item_group", "type": "parameters_item_group"}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["For ", {"text": ["Closed Boundaries"], "type": "ui"}, " as specified on the ", {"_hs_sc": true, "text": ["FLIP Object\n    DOP"], "value": "/nodes/dop/flipobject", "fullpath": "/nodes/dop/flipobject", "scheme": "Node", "type": "link"}, ", particles will be constrained to stay\n    inside the extents of the volumes as specified in the ", {"text": ["Volume\n    Limits"], "type": "ui"}, " tab.  This setting is useful for closed \"tank\" type fluid\n    simulations."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Collide with Volume Limits"]}, {"body": [{"indent": 4, "type": "para", "text": ["Kill any particles outside the volume limits."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Kill Outside Volume Limits"]}, {"body": [{"indent": 4, "type": "para", "text": ["Enable support for particle ", {"text": ["Friction"], "type": "ui"}, " and ", {"text": ["Bounce"], "type": "ui"}, " as specified\n    on the ", {"text": ["Physical"], "type": "ui"}, " tab of the ", {"_hs_sc": true, "text": ["FLIP Object\n    DOP"], "value": "/nodes/dop/flipobject", "fullpath": "/nodes/dop/flipobject", "scheme": "Node", "type": "link"}, ".  Only enabled if ", {"text": ["Collision Detection"], "type": "ui"}, "\n    is set to ", {"text": ["Particle"], "type": "ui"}, "."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Use Friction and Bounce"]}, {"body": [{"indent": 4, "type": "para", "text": ["Add a unique ID attribute to each particle."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Add ID Attribute"]}, {"body": [{"indent": 4, "type": "para", "text": ["Age the particles over time."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Age Particles"]}, {"body": [{"indent": 4, "type": "para", "text": ["Kill any particles whose age attribute is greater than its life attribute."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Reap Particles"]}, {"body": [{"indent": 4, "type": "para", "text": ["Deletes internal attributes that are typically not required in the output of \n    the simulation.  Removing an attribute from this list will ensure it exists\n    at the end of the timestep."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Delete Attributes"]}], "container": true, "role": "item_group", "type": "parameters_item_group"}], "indent": 0, "level": 3, "text": ["Behavior"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Create new particles in voxels where the particle count has dropped\n    too low to properly represent the fluid surface, and delete\n    particles in voxels that have become too crowded.  Reseeding can\n    help avoid collapsing pockets of air forming in the fluid near\n    collisions, as well as provide a smoother surface from which to\n    generate a polygonal mesh."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Reseed Particles"]}, {"body": [{"indent": 4, "type": "para", "text": ["The goal number of particles per voxel."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Particles Per Voxel"]}, {"body": [{"indent": 4, "type": "para", "text": ["The goal number of particles will be scaled by this amount when within\n    ", {"text": ["Oversampling Bandwidth"], "type": "ui"}, " of the surface."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Surface Oversampling"]}, {"body": [{"indent": 4, "type": "para", "text": ["Oversample within this number of voxels from the surface or any\n    ", {"text": ["Surface"], "type": "ui"}, " volume boundaries, if ", {"text": ["Oversample at Boundaries"], "type": "ui"}, " is\n    enabled."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Oversampling Bandwidth"]}, {"body": [{"indent": 4, "type": "para", "text": ["Oversample within ", {"text": ["Oversampling Bandwidth"], "type": "ui"}, " voxels of the fluid\n    volume boundaries. This setting helps avoid collapsing pockets of\n    fluid at the boundaries of a \"Tank\"-type simulation."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Oversample At Boundaries"]}, {"body": [{"indent": 4, "type": "para", "text": ["Particles will be added to a voxel once the current number drops\n    below the product of this parameter and the goal number of\n    particles."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Birth Threshold"]}, {"body": [{"indent": 4, "type": "para", "text": ["Particles will be deleted from a voxel once the current number rises\n    above the product of this parameter and the goal number of\n    particles."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Death Threshold"]}, {"body": [{"indent": 4, "type": "para", "text": ["A seed that controls the time-varying random function used to generate\n    new particle positions when reseeding.  Because high-frequency splashes\n    in a simulation are strongly influenced by particle positions, varying\n    this value (e.g. with a ", {"_hs_sc": true, "text": ["Wedge ROP"], "value": "/nodes/out/wedge", "fullpath": "/nodes/out/wedge", "scheme": "Node", "type": "link"}, ") can generate\n    multiple simulations with similar bulk motion but different splash behavior\n    from otherwise identical simulation parameters."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Random Seed"]}, {"body": [{"indent": 4, "type": "para", "text": ["All attributes matching this pattern will be interpolated to newly\n    seeded particles from the surrounding existing particles.  This interpolation\n    is more expensive than the default nearest neighbor copy, but yields\n    a smoother particle sampling for attributes like velocity.  For example, the\n    ", {"text": ["viscosity"], "type": "code"}, " attribute might be added to this list for fluids smoothly transitioning\n    between melting or freezing, while it should be omitted for \"multi-phase\" fluids\n    with distinct viscosity values."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Interpolate Attributes"]}], "container": true, "role": "item_group", "type": "parameters_item_group"}, {"body": [{"body": [{"indent": 4, "type": "para", "text": ["Setting the various ", {"text": ["Reseeding"], "type": "ui"}, " values too high can lead to fluid\n    gaining volume over time in very splashy fluid simulations.\n    Decreasing the ", {"text": ["Particle Radius Scale"], "type": "ui"}, " or the ", {"text": ["Death Threshold"], "type": "ui"}, "\n    can reduce the volume by causing overcrowded voxels to be pruned\n    earlier.  Decreasing the amount and/or bandwidth of ", {"text": ["Surface\n    Oversampling"], "type": "ui"}, " can help alleviate this problem as well."]}], "indent": 0, "role": "item", "type": "note"}], "container": true, "role": "item_group", "type": "note_group"}], "indent": 0, "level": 3, "text": ["Reseeding"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Despite the velocity projection stage, particles can end up closer\n    together than their ", {"text": ["pscale"], "type": "code"}, " attribute.  When this happens, internal\n    forces can\u2019t separate the particles because the velocity projection\n    will remove those forces.  This results in the fluid compressing\n    over time."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Apply Particle Separation"]}, {"body": [{"indent": 4, "type": "para", "text": ["The number of times to perform the separation relaxation step.  This\n    value can usually be set to 1 since successive frames of separation\n    will have the same effect."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Separation Iterations"]}, {"body": [{"indent": 4, "type": "para", "text": ["How far to move the particles towards their desired separation\n    locations.  This can be reduced to get the effect of a fractional\n    iteration."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Separation Rate"]}, {"body": [{"indent": 4, "type": "para", "text": ["A fudge factor to account for the inability for the particles to\n    actually pack at the ", {"text": ["pscale"], "type": "code"}, " amount due to the sphere packing\n    problem.  To test different values, run a FLIP solve without any\n    volume or particle forces and see which values cause your initial\n    particles to retain the desired volume."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Separation Scale"]}], "container": true, "role": "item_group", "type": "parameters_item_group"}], "indent": 0, "level": 3, "text": ["Separation"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Identify particles that separate from the main body of fluid via a\n    float ", {"text": ["droplet"], "type": "code"}, " attribute that ranges from 0 to 1.  As a particle approaches\n    full droplet status, it will be less influenced by fluid forces.  A fully\n    droplet particle also does not contribute velocity back to the fluid\n    simulation, which can alleviate the problem of individual falling particles\n    causing unrealistically large disturbances on a smooth fluid surface.  Enabling\n    droplets can also break up tendrils on the leading edge of splashes, giving them\n    a more diffuse look."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Detect Droplets"]}, {"body": [{"indent": 4, "type": "para", "text": ["A particle has a droplet value of 1 (droplet) when the surrounding\n    fluid particle density is below this value."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Min Particle Density"]}, {"body": [{"indent": 4, "type": "para", "text": ["A particle has a droplet value of 0 (fluid) when the surrounding\n    fluid particle density is above this value."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Max Particle Density"]}, {"body": [{"indent": 4, "type": "para", "text": ["Controls handling of droplet particles."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["When a fully droplet particle rejoins the fluid, make its velocity a\n        blend between the the droplet\u2019s velocity and the existing fluid velocity,\n        as specified in the ", {"text": ["Velocity Blend"], "type": "ui"}, " parameter."]}], "indent": 4, "type": "dt", "text": ["Blend With Fluid"]}, {"body": [{"indent": 8, "type": "para", "text": ["Immediately kill any fully droplet particles."]}], "indent": 4, "type": "dt", "text": ["Kill On Detection"]}, {"body": [{"indent": 8, "type": "para", "text": ["Kill any fully droplet particles that rejoin the fluid."]}], "indent": 4, "type": "dt", "text": ["Kill At Fluid"]}], "container": true, "type": "dt_group"}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Behavior"]}, {"body": [{"indent": 4, "type": "para", "text": ["Controls the blend between droplet particle velocity and the fluid velocity\n    when ", {"text": ["Behavior"], "type": "ui"}, " is set to ", {"text": ["Blend With Fluid"], "type": "ui"}, "."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Velocity Blend"]}], "container": true, "role": "item_group", "type": "parameters_item_group"}], "indent": 0, "level": 3, "text": ["Droplets"], "container": true, "type": "h", "id": "droplet"}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Compute the vorticity of the fluid velocity field and mix it into the ", {"text": ["vorticity"], "type": "code"}, "\n    attribute on the particles."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Add Vorticity Attribute"]}, {"body": [{"indent": 4, "type": "para", "text": ["The amount of existing vorticity measurement on the particles to preserve\n    per second before mixing in the current computed value.  For example a value\n    of 0.1 will retain 10% of the vorticity measurement over a second."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Preservation Rate"]}, {"body": [{"indent": 4, "type": "para", "text": ["How to blend the computed vorticity with the existing ", {"text": ["vorticity"], "type": "code"}, " attribute value."]}], "indent": 0, "text": ["Mix Method"], "role": "item", "attrs": {"id": "vorticitymix"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["A scale applied to the computed vorticity."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Vorticity Scale"]}], "container": true, "role": "item_group", "type": "parameters_item_group"}], "indent": 0, "level": 3, "text": ["Vorticity"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Creates a ", {"text": ["rest"], "type": "code"}, " attribute, which can be used to track the position of the fluid over time. Turn this on to map noise or textures in the liquid shader."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Add Rest Attribute"]}, {"body": [{"indent": 4, "type": "para", "text": ["Creates a ", {"text": ["rest2"], "type": "code"}, " attribute that is one back from the the main ", {"text": ["rest"], "type": "code"}, " attribute, allowing you to run longer simulations without popping by blending between the two attributes."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Dual Rest Attributes"]}, {"body": [{"indent": 4, "type": "para", "text": ["Number of frames before resetting the rest attributes."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Frames Between Reset"]}, {"body": [{"indent": 4, "type": "para", "text": ["Which frame the rest attributes will be reset on. If you are prerolling the simulation, delaying the rest attribute initialization until after the preroll will usually give a better result."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Frame Offset"]}], "container": true, "role": "item_group", "type": "parameters_item_group"}], "indent": 0, "level": 3, "text": ["Rest"], "container": true, "type": "h", "id": null}], "indent": 0, "level": 2, "text": ["Particle Motion"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Specifies the method used for transferring velocity from the particles\n    to the underlying grid before solving, then back to the particles."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["Transfers the change in velocity from solving back to the particles,\n        along with a small portion of the current velocity as specified by the\n        ", {"text": ["Velocity Smoothing"], "type": "ui"}, " parameter. This method gives splashy, high-energy\n        simulations, but can also introduce noise at the surface which can be distracting\n        for small scale or viscous fluids."]}], "indent": 4, "type": "dt", "text": ["Splashy Kernel"]}, {"body": [{"indent": 8, "type": "para", "text": ["Transfers the velocity field directly to the particles using additional\n        attributes to preserve the angular momentum of the fluid.  This method retains vortices\n        well with reduced noise at the surface, yielding swirling simulations with fewer splashes that\n        can be effective at small scale or high viscosity."]}, {"indent": 8, "type": "para", "text": ["In this case, the transfer radius is based on the voxel size, so using smaller voxels by\n        setting the ", {"text": ["Grid Scale"], "type": "ui"}, " on the ", {"_hs_sc": true, "text": ["FLIP Object"], "value": "/nodes/dop/flipobject", "fullpath": "/nodes/dop/flipobject", "scheme": "Node", "type": "link"}, " to 1.5 can help retain\n        small fluid details.  Because of the larger radius and extra attributes, this method is slightly\n        slower and uses more memory than the ", {"text": ["Splashy Kernel"], "type": "ui"}, ".  Also, the ", {"text": ["Under-Resolved Particles"], "type": "ui"}, "\n        options are disabled for this method, as particles will always be fully resolved on the grid."]}], "indent": 4, "type": "dt", "text": ["Swirly Kernel"]}], "container": true, "type": "dt_group"}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["The ", {"text": ["Splashy Kernel"], "type": "ui"}, " corresponds to the ", {"text": ["FLIP/PIC"], "type": "ui"}, " method of velocity transfer, while the ", {"text": ["Swirly Kernel"], "type": "ui"}, " is implemented with the newer ", {"text": ["APIC"], "type": "ui"}, " method."]}], "indent": 4, "role": "item", "type": "note", "text": [" "]}], "container": true, "role": "item_group", "type": "note_group"}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Velocity Transfer"]}, {"body": [{"indent": 4, "type": "para", "text": ["The result of the velocity projection is a suggested change to the\n    particles velocity.  The force scale allows you to scale this\n    change.  A value of 1 will update the particles to the new desired\n    velocity, 0 will leave them unchanged."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Force Scale"]}, {"body": [{"indent": 4, "type": "para", "text": ["Particles can either update themselves with the change in velocity\n    determined by the projection, or update themselves with the actual\n    new velocity from the projection.  The latter causes particle velocities\n    to smooth out as they share more of their velocities with their\n    neighbors."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Velocity Smoothing"]}, {"body": [{"indent": 4, "type": "para", "text": ["Use a more accurate algorithm for tracking the surface SDF over time,\n    providing smoother surfaces for stationary or slow moving liquids.\n    This improvement may not be noticeable in very turbulent simulations\n    such as rivers or waterfalls and can be disabled for a small performance gain."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Smooth Surface"]}, {"body": [{"indent": 4, "type": "para", "text": ["Controls how the surface SDF is updated at the end of each substep\n    to match the particle positions."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["Do not update the surface SDF."]}], "indent": 4, "type": "dt", "text": ["None"]}, {"body": [{"indent": 8, "type": "para", "text": ["Advect the surface SDF through the velocity field.  This is the\n        faster than Rebuild, but not as accurate."]}], "indent": 4, "type": "dt", "text": ["Advect"]}, {"body": [{"indent": 8, "type": "para", "text": ["Rebuild the entire surface SDF from the particles.  This the\n        most accurate method, but also the slowest."]}], "indent": 4, "type": "dt", "text": ["Rebuild"]}], "container": true, "type": "dt_group"}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["Because particle positions are updated last in the solve order,\n        the surface SDF will lag slightly behind the particle positions\n        if ", {"text": ["Update Surface"], "type": "ui"}, " is set to None."]}], "indent": 4, "role": "item", "type": "note"}], "container": true, "role": "item_group", "type": "note_group"}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Update Surface"]}, {"body": [{"indent": 4, "type": "para", "text": ["Controls how the velocity field is updated at the end of each\n    timestep to match the particle positions."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["Do not update the velocity field."]}], "indent": 4, "type": "dt", "text": ["None"]}, {"body": [{"indent": 8, "type": "para", "text": ["Advect the velocity field through itself.  This is the faster\n        than Rebuild, but not as accurate."]}], "indent": 4, "type": "dt", "text": ["Advect"]}, {"body": [{"indent": 8, "type": "para", "text": ["Rebuild the entire velocity field from the particles.  This the\n        most accurate method, but also the slowest."]}], "indent": 4, "type": "dt", "text": ["Rebuild"]}], "container": true, "type": "dt_group"}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["Because particle positions are updated last in the solve order,\n        the velocity field will lag slightly behind the particle\n        positions if ", {"text": ["Update Velocity"], "type": "ui"}, " is set to None."]}], "indent": 4, "role": "item", "type": "note"}], "container": true, "role": "item_group", "type": "note_group"}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Update Velocity"]}], "container": true, "role": "item_group", "type": "parameters_item_group"}, {"body": [{"indent": 0, "type": "para", "text": ["If stray particles fly off too far, the resulting volume grid can become\nunwieldy even with constant tile compression.  This tab allows you to\nset maximum bounds."]}, {"body": [{"body": [{"indent": 4, "type": "para", "text": ["Display the guide showing the maximum limits of the simulation.  The\n    actual simulation size will most likely be smaller if ", {"text": ["Dynamically\n    Resize Fields"], "type": "ui"}, " is enabled."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Visualize Limits"]}, {"body": [{"indent": 4, "type": "para", "text": ["The size of the maximum volume."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Box Size"]}, {"body": [{"indent": 4, "type": "para", "text": ["The origin of the maximum volume."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Box Origin"]}, {"body": [{"indent": 4, "type": "para", "text": ["Resize the volumes each timestep to contain the particle geometry,\n    within the limits specified. The volumes will be padded by the\n    number of voxels specified in ", {"text": ["Max Cells to Extrapolate"], "type": "ui"}, "."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Dynamically Resize Fields"]}, {"body": [{"indent": 4, "type": "para", "text": ["If the ", {"text": ["Volume Limits"], "type": "ui"}, " change between frames, this option allows\n    particles to be seeded into a new empty region in the volume.\n    ", {"text": ["Use Waterline"], "type": "ui"}, " and ", {"text": ["Use Boundary"], "type": "ui"}, " controls how the new particles\n    are created."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Fill New Volume"]}, {"body": [{"indent": 4, "type": "para", "text": ["If the ", {"text": ["FLIP Object"], "type": "ui"}, " uses ", {"text": ["Closed Boundaries"], "type": "ui"}, ", this option will\n    set each corresponding boundary to be open above the waterline. This\n    allows particles to elegantly leave the simulation and reduces reflections\n    at the boundaries. This can also be used instead of the ", {"text": ["Surface\n    Volume"], "type": "ui"}, " for ", {"text": ["Fill New Volume"], "type": "ui"}, " and ", {"text": ["Use Boundary Layer"], "type": "ui"}, "."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Use Waterline"]}, {"body": [{"indent": 4, "type": "para", "text": ["Display the waterline plane where fluid above the plane can freely flow out of\n    an otherwise closed boundary."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Visualize Waterline"]}, {"body": [{"indent": 4, "type": "para", "text": ["The ", {"text": ["Waterline"], "type": "ui"}, " level and ", {"text": ["Waterline Direction"], "type": "ui"}, " define the waterline plane. Along\n    a closed boundary, simulation voxels above this plane will be set as\n    an open boundary. For ", {"text": ["Fill New Volume"], "type": "ui"}, " and  ", {"text": ["Boundary Layer"], "type": "ui"}, ", the plane\n    is defines the surface, where particles above the plane are considered to be\n    outside of the surface."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Waterline"]}, {"body": [{"indent": 4, "type": "para", "text": ["The waterline direction specifies the \"up\" direction of the waterline plane.\n    The border between the closed and open boundary region is a combination of the \n    waterline level and the waterline direction."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Waterline Direction"]}, {"body": [{"indent": 4, "type": "para", "text": ["Maintaining a thin region around the FLIP simulation can be used to imitate\n    the behavior of an infinite tank. By deleting and reseeding particles\n    according to a provided surface and velocity field, reflections at simulation\n    boundaries can be reduced. Particles entering the boundary layer that are\n    above the specified surface (given by the waterline or surface volume option)\n    will be removed. Particles entering the boundary layer that are below the\n    surface will be assigned a new velocity if the velocity volume option is used."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Use Boundary Layer"]}, {"body": [{"indent": 4, "type": "para", "text": ["The ", {"text": ["Velocity Volume"], "type": "ui"}, " is automatically applied along the ", {"text": ["Closed Boundaries"], "type": "ui"}, " when\n    ", {"text": ["Use Boundary Layer"], "type": "ui"}, " is activated. This option will also overwrite the velocity field\n    inside the boundary layer according to the ", {"text": ["Velocity Volume"], "type": "ui"}, " (or the default of zero\n    velocity when using the waterline). When this is turned off, newly created\n    particles will interpolate velocities from neighbouring particles."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Apply Boundary Velocities"]}, {"body": [{"indent": 4, "type": "para", "text": ["The ", {"text": ["Boundary Layer"], "type": "ui"}, " will be offset into the simulation volume by the specified\n    amount from the lower boundary of the simulation volume."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Lower Padding"]}, {"body": [{"indent": 4, "type": "para", "text": ["The ", {"text": ["Boundary Layer"], "type": "ui"}, " will be offset into the simulation volume by the specified\n    amount from the upper boundary of the simulation volume."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Upper Padding"]}, {"body": [{"indent": 4, "type": "para", "text": ["The surface in boundary layer can be maintained by a provided SDF. Particles\n    above the surface will be removed. The volume below the surface will re-seeded.\n    The particles seeded in a new volume region will be created based on this surface."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Surface Volume"]}, {"body": [{"indent": 4, "type": "para", "text": ["The velocity of the particles in the boundary layer and new volume will be\n    assigned a velocity sampled from this velocity volume."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Velocity Volume"]}], "container": true, "role": "item_group", "type": "parameters_item_group"}], "indent": 0, "level": 3, "text": ["Volume Limits"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Scale the input collision velocities, increasing the effect of\n    moving objects on the fluid and creating bigger splashes, for\n    example.  This value should usually be 1 or greater."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["Use ", {"text": ["Transparency"], "type": "ui"}, " to reduce the overall effect of collisions\n        on fluid."]}], "indent": 4, "role": "item", "type": "note"}], "container": true, "role": "item_group", "type": "note_group"}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Velocity Scale"]}, {"body": [{"indent": 4, "type": "para", "text": ["The method used to calculate collision velocities for colliding DOP\n    Objects. This setting does not affect collision velocities\n    introduced by a ", {"_hs_sc": true, "text": ["Source Volume DOP."], "value": "/nodes/dop/sourcevolume", "fullpath": "/nodes/dop/sourcevolume", "scheme": "Node", "type": "link"}]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["The collision velocity of the objects is calculated by treating\n        it as a rigid body.  Only the angular velocity and linear\n        velocity will be used, no local deformation will be taken into\n        account."]}], "indent": 4, "type": "dt", "text": ["Rigid Velocity"]}, {"body": [{"indent": 8, "type": "para", "text": ["The collision velocity of the objects tries to take into account\n        deformation by using point history.  This only works if the\n        topology doesn\u2019t change."]}], "indent": 4, "type": "dt", "text": ["Point Velocity"]}, {"body": [{"indent": 8, "type": "para", "text": ["Uses the SDF representation of the object to detect deformation.\n        Does not require a fixed topology over time, but cannot detect\n        tangential velocities."]}], "indent": 4, "type": "dt", "text": ["Volume Velocity"]}], "container": true, "type": "dt_group"}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Velocity Type"]}, {"body": [{"indent": 4, "type": "para", "text": ["When the fluid surface is within this voxel distance of a collision,\n    the solver will consider it part of the collision object.  This\n    extrapolation helps fluid flow smoothly along curved surfaces, but\n    can create a slight stickiness.  Decreasing this value can create\n    more dynamic splashes from collisions, especially as objects enter\n    the fluid."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["Setting this to 0 is not recommended."]}], "indent": 4, "role": "item", "type": "note"}], "container": true, "role": "item_group", "type": "note_group"}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Surface Extrapolation"]}, {"body": [{"indent": 4, "type": "para", "text": ["The solver uses fractional estimates of collision volumes to\n    increase the accuracy of the pressure solve around curved or sloped\n    surfaces."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["Estimate the fractional collision weight by determining how much\n        of each voxel face is occluded by the collision volume.  This\n        method provides the smoothest handling of sloped objects, but\n        can treat square objects as excessively smooth."]}], "indent": 4, "type": "dt", "text": ["Voxel Face Area"]}, {"body": [{"indent": 8, "type": "para", "text": ["Estimate the fractional collision weight by sampling the\n        collision volume multiple times for each voxel. This method\n        handles square-shaped collision objects better, but can\n        introduce some false friction-like forces on sloped surfaces."]}], "indent": 4, "type": "dt", "text": ["Collision Supersampling"]}, {"body": [{"indent": 8, "type": "para", "text": ["Do not calculate collision weights.  This should only be used by\n        advanced users for a high degree of control over the collision\n        weights by calculating them manually, usually with a ", {"_hs_sc": true, "text": ["Gas SDF To\n        Fog DOP."], "value": "/nodes/dop/gassdftofog", "fullpath": "/nodes/dop/gassdftofog", "scheme": "Node", "type": "link"}, " attached to the ", {"text": ["Volume\n        Velocity"], "type": "ui"}, " input."]}], "indent": 4, "type": "dt", "text": ["None"]}], "container": true, "type": "dt_group"}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Volume Fraction Method"]}, {"body": [{"indent": 4, "type": "para", "text": ["How many samples are taken per axis when the ", {"text": ["Volume Fraction\n    Method"], "type": "ui"}, " is set to ", {"text": ["Collision Supersampling"], "type": "ui"}, ".  Increasing this\n    value makes for a more accurate estimate, but note that the total\n    number of samples taken is the ", {"text": ["cube"], "type": "em"}, " of this number."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Samples Per Axis"]}, {"body": [{"indent": 4, "type": "para", "text": ["Make all collision objects \"transparent\" to the fluid by this\n    amount, decreasing the effect of objects on the fluid and allowing\n    some fluid to flow through the objects."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["If using ", {"text": ["Transparency"], "type": "ui"}, ", the ", {"text": ["Collision Detection"], "type": "ui"}, " method of\n        the ", {"text": ["Particle Motion"], "type": "ui"}, " tab should usually be set to ", {"text": ["None"], "type": "ui"}, ",\n        otherwise the particle collision detection will not allow any\n        particles to intrude into collision objects, no matter what the\n        ", {"text": ["Transparency"], "type": "ui"}, " value."]}], "indent": 4, "role": "item", "type": "note"}], "container": true, "role": "item_group", "type": "note_group"}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Transparency"]}, {"body": [{"indent": 4, "type": "para", "text": ["Causes the fluid\u2019s velocity to match the collision velocity when\n    close to collision objects.  See the \n    ", {"_hs_sc": true, "text": ["Gas Stick On Collision DOP"], "value": "/nodes/dop/gasstickoncollision", "fullpath": "/nodes/dop/gasstickoncollision", "scheme": "Node", "type": "link"}, " for more\n    information."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Stick on Collision"]}, {"body": [{"indent": 4, "type": "para", "text": ["The amount of collision velocity to blend into the fluid\u2019s velocity,\n    where a value of 1 indicates fully matching the collision velocity."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Stick Scale"]}, {"body": [{"indent": 4, "type": "para", "text": ["Specifies the world-space distance within which to apply the effect."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Max Distance"]}, {"body": [{"indent": 4, "type": "para", "text": ["Specifies the maximum number of voxels within which to apply the\n    effect."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Max Cells"]}, {"body": [{"indent": 4, "type": "para", "text": ["Controls how quickly within the stick distance the effect will reach\n    the full ", {"text": ["Stick Scale"], "type": "ui"}, ". Values closer to 1 will have more effect\n    throughout the stick distance."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Stick Bias"]}, {"body": [{"indent": 4, "type": "para", "text": ["Scale the amount of velocity adjustment in the direction normal to the collision surface."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Normal Scale"]}, {"body": [{"indent": 4, "type": "para", "text": ["Scale the amount of velocity adjustment in the direction tangent to the collision surface."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Tangent Scale"]}], "container": true, "role": "item_group", "type": "parameters_item_group"}, {"body": [{"body": [{"indent": 4, "type": "para", "text": ["Keeping a high ", {"text": ["Normal Scale"], "type": "ui"}, " and decreasing the ", {"text": ["Tangent Scale"], "type": "ui"}, " can create a \"sticktion\" effect, where the fluid flows quickly around the collision but remains stuck to the surface."]}], "indent": 0, "role": "item", "type": "tip"}], "container": true, "role": "item_group", "type": "tip_group"}, {"body": [{"body": [{"indent": 4, "type": "para", "text": ["Scale the effect by this spatially varying field, which should match the collision field in resolution."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Control Field"]}], "container": true, "role": "item_group", "type": "parameters_item_group"}], "indent": 0, "level": 3, "text": ["Collisions"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["See ", {"_hs_sc": true, "fragment": "#viscosity", "text": ["the discussion of viscosity"], "value": "/fluid/liquids#viscosity", "fullpath": "/fluid/liquids#viscosity", "scheme": null, "type": "link"}, " in the\n    user guide."]}], "indent": 0, "role": "item", "type": "note"}], "container": true, "role": "item_group", "type": "note_group"}, {"body": [{"body": [{"indent": 4, "type": "para", "text": ["Enable the viscosity solver."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Enable Viscosity"]}, {"body": [{"indent": 4, "type": "para", "text": ["Use the specified attribute to overwrite the viscosity field."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Viscosity by Attribute"]}, {"body": [{"indent": 4, "type": "para", "text": ["The float attribute on the particles to use for the viscosity\n    amount."]}], "indent": 0, "text": ["Attribute Name"], "role": "item", "attrs": {"id": "viscosityattrib"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["How to blend the point attribute with the existing viscosity field."]}], "indent": 0, "text": ["Mix Method"], "role": "item", "attrs": {"id": "viscositymix"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["A scale applied to the Viscosity field after applying the attribute\n    effect.  This is useful for quickly adjusting the global amount of\n    viscosity."]}], "indent": 0, "text": ["Viscosity Scale"], "role": "item", "attrs": {"id": "viscosityscale"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["This parameter controls the floating point precision used\n    internally by the viscosity solver. ", {"text": ["Float 32 bit"], "type": "ui"}, " uses less memory and is\n    generally faster than ", {"text": ["Float 64 bit"], "type": "ui"}, ". However, the extra accuracy of 64-bit\n    floating point numbers may be needed when simulating fluid with very high\n    viscosity or large variations in viscosity."]}], "indent": 0, "text": ["Float Precision"], "role": "item", "attrs": {"id": "viscosityprecision"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["Causes the collision velocity to match the fluid velocity when close to\n    collision objects. This allows a viscous fluid to slide along the collision\n    object."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Slip on Collision"]}, {"body": [{"indent": 4, "type": "para", "text": ["The amount of fluid velocity to blend into the collision\u2019s tangential \n    velocity, where a value of 1 indicates fully matching the fluid velocity."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Slip Scale"]}, {"body": [{"indent": 4, "type": "para", "text": ["Scale the effect by this spatially varying field, which should match the collision\n    field in resolution."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Control Field"]}], "container": true, "role": "item_group", "type": "parameters_item_group"}], "indent": 0, "level": 3, "text": ["Viscosity"], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "text": ["By default, the fluid has uniform density as set on the ", {"text": ["Physical"], "type": "ui"}, " tab\nof the ", {"_hs_sc": true, "text": ["FLIP Object"], "value": "/nodes/dop/flipobject", "fullpath": "/nodes/dop/flipobject", "scheme": "Node", "type": "link"}, ". To simulate fluids of varying\ndensity, you can use a per-particle density attribute to control the\ndensity throughout the fluid."]}, {"indent": 0, "type": "para", "text": ["If you override the ", {"text": ["Density"], "type": "ui"}, " field through the ", {"text": ["Volume Velocity"], "type": "ui"}, "\ninput to the flip solver, you can arbitrarily edit the density field."]}, {"body": [{"body": [{"indent": 4, "type": "para", "text": ["Use the specified attribute to manipulate the density field."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Density by Attribute"]}, {"body": [{"indent": 4, "type": "para", "text": ["The float attribute on the particles to use for the density amount."]}], "indent": 0, "text": ["Attribute Name"], "role": "item", "attrs": {"id": "densityattrib"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["How to blend the point attribute with the existing density field."]}], "indent": 0, "text": ["Mix Method"], "role": "item", "attrs": {"id": "densitymix"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["A scale applied to the Density field after applying the attribute\n    effect.  This is useful for quickly adjusting the global amount of\n    density."]}], "indent": 0, "text": ["Density Scale"], "role": "item", "attrs": {"id": "densityscale"}, "type": "parameters_item"}], "container": true, "role": "item_group", "type": "parameters_item_group"}, {"body": [{"body": [{"indent": 4, "type": "para", "text": ["By setting the ", {"text": ["Mix Method"], "type": "ui"}, " to Multiply, you can use relative\n    density values that scale the default fluid density.  A density\n    attribute of 1, for example, will have the density of water by\n    default, while a density attribute of 0.5 would indicate fluid of\n    half that density.  Relative density is also known as ", {"text": ["specific\n    gravity"], "type": "em"}, "; values for typical liquids can be found\n    ", {"_hs_sc": true, "exists": true, "text": ["here"], "value": "http://www.engineeringtoolbox.com/specific-gravity-liquids-d_336.html", "scheme": null, "type": "link"}, ".\n    Note that because the FLIP Solver does not explicitly track the\n    boundary between fluids of different densities, it might be\n    necessary to exaggerate density ratios to avoid excess mixing."]}], "indent": 0, "role": "item", "type": "tip"}], "container": true, "role": "item_group", "type": "tip_group"}], "indent": 0, "level": 3, "text": ["Density"], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "text": ["By default, the volume motion is divergence free.  These enforces\nneighboring particles to neither separate nor converge.  However, you\nmay want to adjust the particle spacing.  Doing this with forces is\ndifficult because the volume projection will undo your forces."]}, {"indent": 0, "type": "para", "text": ["Instead, you can add a per-particle float attribute to store how much\nthe particles should diverge.  Positive values cause particles to spread\nout, and negative values cause them to clump together."]}, {"indent": 0, "type": "para", "text": ["If you override the ", {"text": ["Divergence"], "type": "ui"}, " field through the ", {"text": ["Volume Velocity"], "type": "ui"}, "\ninput to the flip solver, you can arbitrarily edit the divergence field."]}, {"indent": 0, "type": "para", "text": ["You must turn on ", {"text": ["Add Divergence Field"], "type": "ui"}, " in the ", {"_hs_sc": true, "text": ["FLIP\nObject"], "value": "/nodes/dop/flipobject", "fullpath": "/nodes/dop/flipobject", "scheme": "Node", "type": "link"}, " for this to work."]}, {"body": [{"body": [{"indent": 4, "type": "para", "text": ["Use the specified attribute to overwrite the divergence field."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Diverge by Attribute"]}, {"body": [{"indent": 4, "type": "para", "text": ["The float attribute on the particles to use for the divergence\n    amount."]}], "indent": 0, "text": ["Attribute Name"], "role": "item", "attrs": {"id": "divergenceattrib"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["How to blend the point attribute with any existing divergence field.\n    The divergence field is not reset frame-to-frame."]}], "indent": 0, "text": ["Mix Method"], "role": "item", "attrs": {"id": "divergencemix"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["A scale applied to the divergence field after applying the attribute\n    effect.  This is useful for quickly adjusting the global amount of\n    divergence."]}], "indent": 0, "text": ["Divergence Scale"], "role": "item", "attrs": {"id": "divergencescale"}, "type": "parameters_item"}], "container": true, "role": "item_group", "type": "parameters_item_group"}], "indent": 0, "level": 3, "text": ["Divergence"], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "text": ["Surface tension flattens irregular features and pulls water into\ndroplets.  It is useful for small-scale simulations where the\neffect of surface tension is often more important than gravity\nin controlling the dynamics."]}, {"indent": 0, "type": "para", "text": ["For large values, additional substeps are often required to ensure\nstability."]}, {"indent": 0, "type": "para", "text": ["Enabling surface tension will create the ", {"text": ["surfacepressure"], "type": "code"}, " field.\nThis field can be used for other effects than just surface tension,\nsuch as suction or avoidance."]}, {"body": [{"body": [{"indent": 4, "type": "para", "text": ["Enable the ", {"text": ["surfacepressure"], "type": "code"}, " field."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Enable Surface Tension"]}, {"body": [{"indent": 4, "type": "para", "text": ["The magnitude of the surface tension.  This depends on the mass-density\n    of the fluid, so must be changed if the mass-density is changed."]}, {"indent": 4, "type": "para", "text": ["Given the same object, but reduced particle separation (ie, a higher\n    resolution simulation), you may need to reduce the magnitude of the\n    surface tension to maintain the same qualitative result."]}, {"indent": 4, "type": "para", "text": ["Negative values will cause the surface to rip itself apart in a\n    spectacular fashion."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Surface Tension"]}], "container": true, "role": "item_group", "type": "parameters_item_group"}], "indent": 0, "level": 3, "text": ["Surface Tension"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Indicates the scale of the simulation. This value controls the\n    tolerance of various particle operations, particularly moving\n    particles to match SDF iso surface values, and some solver defaults\n    for density and viscosity.  If your scene is modeled in meters, then\n    the default value of 1 is sufficient. However, if your scene is\n    modeled in centimeters, you should set ", {"text": ["Spatial Scale"], "type": "ui"}, " to 0.01."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["Choose the correct ", {"text": ["Unit Length"], "type": "ui"}, " in ", {"text": ["Edit"], "type": "ui"}, " > ", {"text": ["Preferences"], "type": "ui"}, "\n        > ", {"text": ["Hip File Options"], "type": "ui"}, " before you create your DOP network. That\n        way, the FLIP solver node will automatically get the correct\n        ", {"text": ["Spatial Scale"], "type": "ui"}, " when it\u2019s created."]}], "indent": 4, "role": "item", "type": "tip"}], "container": true, "role": "item_group", "type": "tip_group"}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Spatial Scale"]}, {"body": [{"indent": 4, "type": "para", "text": ["Indicates the mass scale of the simulation. This value controls the\n    solver tolerance for density and viscosity.  If your scene is\n    modeled in kilograms, then the default value of 1 is sufficient.\n    However, if your scene is modeled in grams, you should set ", {"text": ["Spatial\n    Scale"], "type": "ui"}, " to 0.001."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["Choose the correct ", {"text": ["Unit Mass"], "type": "ui"}, " in ", {"text": ["Edit"], "type": "ui"}, " > ", {"text": ["Preferences"], "type": "ui"}, " >\n        ", {"text": ["Hip File Options"], "type": "ui"}, " before you create your DOP network. That\n        way, the FLIP solver node will automatically get the correct\n        ", {"text": ["Mass Scale"], "type": "ui"}, " when it\u2019s created."]}], "indent": 4, "role": "item", "type": "tip"}], "container": true, "role": "item_group", "type": "tip_group"}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Mass Scale"]}, {"body": [{"indent": 4, "type": "para", "text": ["A scale factor used in applying feedback forces to other objects.  A\n    value of zero prevents any feedback from occurring."]}, {"indent": 4, "type": "para", "text": ["The default ", {"_hs_sc": true, "text": ["RBD object"], "value": "/nodes/dop/rbdobject", "fullpath": "/nodes/dop/rbdobject", "scheme": "Node", "type": "link"}, " has the same density as\n    water, so to balance with the default fluid density a value of 1\n    should be used."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Feedback Scale"]}, {"body": [{"indent": 4, "type": "para", "text": ["Controls the method used for extrapolating velocity in the solver."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["A fast method that properly handles curved collision\n        containers.  This is the recommended extrapolation mode."]}], "indent": 4, "type": "dt", "text": ["Normal"]}, {"body": [{"indent": 8, "type": "para", "text": ["A slower method that can be more accurate with fast moving\n        colliders and a low number of substeps."]}], "indent": 4, "type": "dt", "text": ["Fast-moving Colliders"]}], "container": true, "type": "dt_group"}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Extrapolation Mode"]}, {"body": [{"indent": 4, "type": "para", "text": ["Improve handling of fast-moving fluid by automatically increasing\n    the extrapolation distance based on the fluid\u2019s speed.  In most\n    cases, this avoids tuning the ", {"text": ["Max Cells To Extrapolate"], "type": "ui"}, " parameter.\n    The final extrapolation distance is the greater of \n    ", {"text": ["Max Cells To Extrapolate"], "type": "ui"}, "  and the speed-calculated value."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Automatic Extrapolation By Speed"]}, {"body": [{"indent": 4, "type": "para", "text": ["The number of non-fluid cells that should be filled with velocity\n    values on the non-fluid side of the velocity field. Increase this\n    value for very fast-moving fluids and/or a low number of substeps."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Max Cells to Extrapolate"]}, {"body": [{"indent": 4, "type": "para", "text": ["During the pressure projection and viscosity solves, the matrices\n    involved can be preconditioned to speed up the solution.  However,\n    this is a single threaded process.  On machines with 4+ sockets it\n    may be faster to disable this preconditioning and use a simpler\n    Jacobi preconditioner which multithreads well, but can take more\n    iterations to converge."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Use Preconditioner"]}, {"body": [{"indent": 4, "type": "para", "text": ["Solve the linear systems for viscosity and pressure using OpenCL. \n    This setting is mostly beneficial for high resolution fluid simulations\n    with viscosity, when run on a fast GPU."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Use OpenCL"]}], "container": true, "role": "item_group", "type": "parameters_item_group"}, {"body": [{"body": [{"indent": 4, "type": "para", "text": ["The following collision fields are used mainly for creating guiding simulations.\n    They are only connected to the collision fields in both the pressure and\n    viscosity solvers. All other nodes that apply collision information use the\n    internal fields. Please refer to ", {"_hs_sc": true, "text": ["Gas Guiding Volume DOP"], "value": "/nodes/dop/gasguidingvolume", "fullpath": "/nodes/dop/gasguidingvolume", "scheme": "Node", "type": "link"}, "\n    for more information about creating guiding fields."]}], "indent": 0, "role": "item", "type": "note"}], "container": true, "role": "item_group", "type": "note_group"}, {"body": [{"body": [{"indent": 4, "type": "para", "text": ["The collision surface that is connected to pressure and viscosity solvers."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Collision Surface"]}, {"body": [{"indent": 4, "type": "para", "text": ["The collision weights improve the accuracy of the pressure and viscosity solvers."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Collision Weights"]}, {"body": [{"indent": 4, "type": "para", "text": ["The collision velocity is applied to the fluid through the solvers at the collision surface."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Collision Velocity"]}], "container": true, "role": "item_group", "type": "parameters_item_group"}, {"body": [{"body": [{"indent": 4, "type": "para", "text": ["The following fields are used mainly to maintain FLIP particles for guiding\n    simulations. These fields are connected to a ", {"_hs_sc": true, "text": ["Gas Seed Markers DOP"], "value": "/nodes/dop/gasseedmarkers", "fullpath": "/nodes/dop/gasseedmarkers", "scheme": "Node", "type": "link"}, "."]}], "indent": 0, "role": "item", "type": "note"}], "container": true, "role": "item_group", "type": "note_group"}, {"body": [{"body": [{"indent": 4, "type": "para", "text": ["FLIP particles are seeded into the source surface. This is useful for allowing\n    the fluid to flow out of a guiding simulation surface."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Source Surface"]}, {"body": [{"indent": 4, "type": "para", "text": ["FLIP particles are removed when they enter the sink surface. This is useful\n    for removing unneeded particles that flow deep into a guiding simulation surface."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Sink Surface"]}], "container": true, "role": "item_group", "type": "parameters_item_group"}], "indent": 0, "level": 3, "text": ["Solver"], "container": true, "type": "h", "id": null}, {"body": [{"indent": 4, "type": "para", "text": ["FLIP simulations are distributed in the same manner as particle\n    simulations; by first specifying a series of Slice planes that\n    divide space up.  Each machine then is responsible for the fluid\n    that lies within its slice."]}, {"indent": 4, "type": "para", "text": ["Each substep all particles along the slice boundaries are exchanged.\n    The bandwidth specified should thus be large enough to cover how far\n    particles are expected to move in a substep."]}, {"indent": 4, "type": "para", "text": ["All machines synchronize their substep size automatically, so variable\n    substeps can be used."]}, {"body": [{"body": [{"indent": 4, "type": "para", "text": ["What machine will run the simtracker.py process for synchronization.\n    If this is blank, there will be no attempt at synchronization or data transfer."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Tracker Address"]}, {"body": [{"indent": 4, "type": "para", "text": ["The port specified when starting the simtracker.py process for\n    communication."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Tracker Port"]}, {"body": [{"indent": 4, "type": "para", "text": ["The job name to describe this synchronization or data exchange\n    event.  By using different job names one can have machines part of\n    separate data-exchange and synchronization events."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Job Name"]}, {"body": [{"indent": 4, "type": "para", "text": ["The slice number that this machine should report itself as.  Each\n    machine connecting under the job name should have its own unique\n    slice number.  Sometimes this can be inferred from the operation\n    so this parameter will be absent."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Slice/Peer"]}, {"body": [{"indent": 4, "type": "para", "text": ["Total number of machines that have to synchronize.  Sometimes this\n    can be determined from the operation, so this parameter will be\n    absent."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Number of Slice/Number of Peers"]}, {"body": [{"indent": 8, "type": "para", "text": ["The pressure projection may be distributed across machines.  This\n        avoids any loss of fluid and is required for tank-style simulations,\n        but not needed for flowing rivers.  It requires considerably more\n        network bandwidth, so becomes advantageous only with very large simulations."]}], "indent": 4, "role": "item", "type": "parameters_item", "text": ["Distributed Pressure Solve"]}], "container": true, "type": "parameters_item_group"}], "indent": 0, "level": 3, "text": ["Distribution"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"indent": 4, "type": "para", "text": ["Each data option parameter has an associated menu which specifies\n    how that parameter operates."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["Use the value from the Default Operation menu."]}], "indent": 4, "type": "dt", "text": ["Use Default "]}, {"body": [{"indent": 8, "type": "para", "text": ["Set the value of this parameter only when this data is created.\n        On all subsequent timesteps, the value of this parameter is not\n        altered. This is useful for setting up initial conditions like\n        position and velocity."]}], "indent": 4, "type": "dt", "text": ["Set Initial "]}, {"body": [{"indent": 8, "type": "para", "text": ["Always set the value of this parameter. This is useful when\n        specific keyframed values are required over time. This could be\n        used to keyframe the position of an object over time, or to\n        cause the geometry from a SOP to be refetched at each timestep\n        if the geometry is deforming. "]}, {"indent": 8, "type": "para", "text": ["You can also use this setting in\n        conjunction with the local variables for a parameter value to\n        modify a value over time. For example, in the X Position, an\n        expression like ", {"text": ["$tx + 0.1"], "type": "code"}, " would cause the object to\n        move 0.1 units to the right on each timestep."]}], "indent": 4, "type": "dt", "text": ["Set Always "]}, {"body": [{"indent": 8, "type": "para", "text": ["Do not ever set the value of this parameter. This option is most\n        useful when using this node to modify an existing piece of data\n        connected through the first input. "]}, {"indent": 8, "type": "para", "text": ["For example, an ", {"_hs_sc": true, "text": ["RBD State\n        DOP"], "value": "/nodes/dop/rbdstate", "fullpath": "/nodes/dop/rbdstate", "scheme": "Node", "type": "link"}, " may want to animate just the mass of an\n        object, and nothing else. The ", {"text": ["Set Never"], "type": "ui"}, " option could be used\n        on all parameters except for ", {"text": ["Mass"], "type": "ui"}, ", which would use ", {"text": ["Set\n        Always"], "type": "ui"}, "."]}], "indent": 4, "type": "dt", "text": ["Set Never "]}], "container": true, "type": "dt_group"}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Parameter Operations"]}, {"body": [{"indent": 4, "type": "para", "text": ["For any parameters with their ", {"text": ["Operation"], "type": "ui"}, " menu set to ", {"text": ["Use\n    Default"], "type": "ui"}, ", this parameter controls what operation is used. "]}, {"indent": 4, "type": "para", "text": ["This\n    parameter has the same menu options and meanings as the ", {"text": ["Parameter\n    Operations"], "type": "ui"}, " menus, but without the ", {"text": ["Use Default"], "type": "ui"}, " choice."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Default Operation"]}, {"body": [{"indent": 4, "type": "para", "text": ["All objects connected to the first input of this node become mutual\n    affectors. "]}, {"indent": 4, "type": "para", "text": ["This is equivalent to using an ", {"_hs_sc": true, "text": ["Affector\n    DOP"], "value": "/nodes/dop/affector", "fullpath": "/nodes/dop/affector", "scheme": "Node", "type": "link"}, " to create an affector relationship between\n    ", {"text": ["*"], "type": "code"}, " and ", {"text": ["*"], "type": "code"}, " before connecting it to this node. This option makes it\n    convenient to have all objects feeding into a solver node affect\n    each other."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Make Objects Mutual Affectors"]}, {"body": [{"indent": 4, "type": "para", "text": ["When an object connector is attached to the first input of this\n    node, this parameter can be used to choose a subset of those objects\n    to be affected by this node."]}], "indent": 0, "text": ["Group"], "role": "item", "attrs": {"channels": "/group"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["Indicates the name that should be used to attach the data to an\n    object or other piece of data. If the Data Name contains a \"/\" (or\n    several), that indicates traversing inside subdata. "]}, {"indent": 4, "type": "para", "text": ["For example, if the ", {"_hs_sc": true, "text": ["Fan Force DOP"], "value": "/nodes/dop/fan", "fullpath": "/nodes/dop/fan", "scheme": "Node", "type": "link"}, " has the default Data Name\n    \"Forces/Fan\". This attaches the data with the name \"Fan\" to an\n    existing piece of data named \"Forces\". If no data named \"Forces\"\n    exists, a simple piece of container data is created to hold the\n    \"Fan\" subdata."]}, {"indent": 4, "type": "para", "text": ["Different pieces of data have different requirements on what names\n    should be used for them. Except in very rare situations, the default\n    value should be used. Some exceptions are described with particular\n    pieces of data or with solvers that make use of some particular type\n    of data."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Data Name"]}, {"body": [{"indent": 4, "type": "para", "text": ["Turning on this parameter modifies the ", {"text": ["Data Name"], "type": "ui"}, " parameter\n    value to ensure that the data created by this node is attached with\n    a unique name so it will not overwrite any existing data. "]}, {"indent": 4, "type": "para", "text": ["With this\n    parameter turned off, attaching two pieces of data with the same\n    name will cause the second one to replace the first. There are\n    situations where each type of behavior is desirable. "]}, {"indent": 4, "type": "para", "text": ["If an object\n    needs to have several ", {"_hs_sc": true, "text": ["Fan Forces"], "value": "/nodes/dop/fan", "fullpath": "/nodes/dop/fan", "scheme": "Node", "type": "link"}, " blowing on it, it is\n    much easier to use the ", {"text": ["Unique Data Name"], "type": "ui"}, " feature to ensure that\n    each fan does not overwrite a previous fan rather than trying to\n    change the ", {"text": ["Data Name"], "type": "ui"}, " of each fan individually to avoid\n    conflicts. "]}, {"indent": 4, "type": "para", "text": ["On the other hand, if an object is known to have ", {"_hs_sc": true, "text": ["RBD\n    State"], "value": "/nodes/dop/rbdstate", "fullpath": "/nodes/dop/rbdstate", "scheme": "Node", "type": "link"}, " data already attached to it, leaving this\n    option turned off will allow some new ", {"_hs_sc": true, "text": ["RBD State"], "value": "/nodes/dop/rbdstate", "fullpath": "/nodes/dop/rbdstate", "scheme": "Node", "type": "link"}, "\n    data to overwrite the existing data."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Unique Data Name"]}, {"body": [{"indent": 4, "type": "para", "text": ["The default behavior for solvers is to attach the exact same solver to all\n    of the objects specified in the group.  This allows the objects to be\n    processed in a single pass by the solver, since the parameters are identical\n    for each object.  However, some objects operate more logically on a single\n    object at a time.  In these cases, one may want to use ", {"text": ["$OBJID"], "type": "code"}, " expressions\n    to vary the solver parameters across the objects.  Setting this toggle will\n    create a separate solver per object, allowing ", {"text": ["$OBJID"], "type": "code"}, " to vary as expected."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Solver Per Object"]}], "container": true, "type": "parameters_item_group"}], "indent": 0, "level": 2, "text": ["Volume Motion"], "container": true, "type": "h", "id": null}], "indent": 0, "level": 1, "text": "Parameters", "role": "section", "container": true, "type": "parameters_section", "id": "parameters"}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["The simulation object to evolve as a particle fluid."]}], "indent": 0, "type": "dt", "text": ["Fluid to Solve"]}, {"body": [{"indent": 4, "type": "para", "text": ["This input injects microsolvers after the particle velocity has been\n    updated but before it has been transferred to the volume fields.  It\n    is thus the ideal place to add solvers that manipulate the particle\n    velocity or position still farther."]}], "indent": 0, "type": "dt", "text": ["Particle Velocity"]}, {"body": [{"indent": 4, "type": "para", "text": ["Solvers in the volume velocity input are added after the volume\n    velocity field has been created but before it has been made\n    non-divergent.  This is the best place for field-affecting\n    microsolvers to be attached, and the only place for microsolvers\n    that want to add forces to the velocity field."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["Solvers attached to this input should not create or delete\n        particles."]}], "indent": 4, "role": "item", "type": "note"}], "container": true, "role": "item_group", "type": "note_group"}], "indent": 0, "type": "dt", "text": ["Volume Velocity"]}, {"body": [{"indent": 4, "type": "para", "text": ["The main use for this input is to add or remove particles using the\n    ", {"_hs_sc": true, "text": ["Source Volume node"], "value": "/nodes/dop/sourcevolume", "fullpath": "/nodes/dop/sourcevolume", "scheme": "Node", "type": "link"}, " that imports particles\n    and volumes from a geometry network. See ", {"_hs_sc": true, "text": ["fluid\n    sourcing"], "value": "/dyno/fluid_sourcing", "fullpath": "/dyno/fluid_sourcing", "scheme": null, "type": "link"}, " for more information."]}, {"indent": 4, "type": "para", "text": ["Nodes attached to this input can also edit the simulation network\u2019s\n    velocity fields, for example to apply custom forces, ", {"text": ["after"], "type": "em"}, " the\n    main simulation steps."]}], "indent": 0, "type": "dt", "text": ["Sourcing (post-solve)"]}], "container": true, "type": "dt_group"}], "indent": 0, "level": 1, "text": "Inputs", "role": "section", "container": true, "type": "inputs_section", "id": "inputs"}, {"body": [{"body": [{"body": [{"type": "para", "indent": 4, "text": ["The operation of this output depends on what inputs are connected\n    to this node. If an object stream is input to this node, the output\n    is also an object stream containing the same objects as the input\n    (but with the data from this node attached). "]}, {"type": "para", "indent": 4, "text": ["If no object stream is\n    connected to this node, the output is a data output. This data\n    output can be connected to an ", {"_hs_sc": true, "text": ["Apply Data DOP"], "value": "/nodes/dop/applydata", "fullpath": "/nodes/dop/applydata", "scheme": "Node", "type": "link"}, ",\n    or connected directly to a data input of another data node, to\n    attach the data from this node to an object or another piece of\n    data."]}], "type": "dt", "indent": 0, "text": ["First Output"]}], "type": "dt_group", "container": true}], "indent": 0, "level": 1, "text": "Outputs", "role": "section", "container": true, "type": "outputs_section", "id": "outputs"}, {"body": [{"body": [{"indent": 0, "blevel": 2, "type": "bullet", "text": [{"_hs_sc": true, "text": "", "value": "/nodes/dop/flipobject", "fullpath": "/nodes/dop/flipobject", "scheme": "Node", "type": "link"}]}, {"indent": 0, "blevel": 2, "type": "bullet", "text": [{"_hs_sc": true, "text": "", "value": "/nodes/dop/particlefluidemitter", "fullpath": "/nodes/dop/particlefluidemitter", "scheme": "Node", "type": "link"}]}, {"indent": 0, "blevel": 2, "type": "bullet", "text": [{"_hs_sc": true, "text": "", "value": "/nodes/dop/particlefluidsink", "fullpath": "/nodes/dop/particlefluidsink", "scheme": "Node", "type": "link"}]}, {"indent": 0, "blevel": 2, "type": "bullet", "text": [{"_hs_sc": true, "text": "", "value": "/nodes/dop/gasintegrator", "fullpath": "/nodes/dop/gasintegrator", "scheme": "Node", "type": "link"}]}, {"indent": 0, "blevel": 2, "type": "bullet", "text": [{"_hs_sc": true, "text": "", "value": "/nodes/sop/particlefluidsurface", "fullpath": "/nodes/sop/particlefluidsurface", "scheme": "Node", "type": "link"}]}], "container": true, "type": "bullet_group"}], "indent": 0, "level": 1, "text": "Related", "role": "section", "container": true, "type": "related_section", "id": "related"}], "title": ["FLIP Solver"], "summary": ["Evolves an object as a FLIP fluid object."], "attrs": {"version": "2.0", "namespace": null, "internal": "flipsolver::2.0", "context": "dop", "type": "node", "icon": "DOP/flipsolver"}, "included": ["/nodes/dop/standard_dataop_parms.txt", "/nodes/dop/standard_dataname_parms.txt", "/nodes/dop/standard_solver_mutualparms.txt", "/nodes/dop/standard_solver_parms.txt", "/nodes/dop/standard_datagroup_parms.txt", "/nodes/dop/standard_distribution.txt", "/nodes/dop/standard_data_outputs.txt"], "type": "root"}