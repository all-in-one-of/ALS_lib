{"body": [{"indent": 0, "text": ["Channel"], "type": "title", "level": 0}, {"indent": 0, "type": "summary", "text": ["Reads sample data from a chop and converts it into point positions\nand point attributes."]}, {"indent": 0, "type": "para", "text": ["This node is complementary to the\n", {"_hs_sc": true, "text": ["Geometry CHOP"], "value": "/nodes/chop/geometry", "fullpath": "/nodes/chop/geometry", "scheme": "Node", "type": "link"}, ". The Channels created by the\n", {"_hs_sc": true, "text": ["Geometry CHOP"], "value": "/nodes/chop/geometry", "fullpath": "/nodes/chop/geometry", "scheme": "Node", "type": "link"}, " can be modified and then re-inserted\ninto the op network via a Channel SOP."]}, {"indent": 0, "type": "para", "text": ["This does what a ", {"_hs_sc": true, "text": ["Point SOP"], "value": "/nodes/sop/point", "fullpath": "/nodes/sop/point", "scheme": "Node", "type": "link"}, " with a ", {"text": ["chopci()"], "type": "code"}, " function can\ndo, but is much faster."]}, {"indent": 0, "type": "para", "text": ["There are two different ways of importing attribute values, \ncontrolled by the  ", {"text": ["Method"], "type": "ui"}, " parameter. Each method requires that the CHOP \nchannels are set up in a specific way."]}, {"indent": 0, "type": "para", "text": ["The  ", {"text": ["Static"], "type": "ui"}, " method is used for modeling a surface without any animation. \nA single channel is required for each attribute component, and its length must\nbe the number of points in the geometry or specified point group(s). \nTo modify ", {"text": ["P"], "type": "code"}, " in a geometry with 100 points, three channels with 100 samples \nwould be required."]}, {"indent": 0, "type": "para", "text": ["The second method, ", {"text": ["Animated"], "type": "ui"}, ", provides animation for the attribute. \nThere must be one set of channels for each attribute component, and this set\nmust be indexed from 0 to the number of points minus one, by adding a numeric\nsuffix. For the attributes ", {"text": ["Cd Alpha"], "type": "code"}, " with 3 points, you would need \n", {"text": ["r0 g0 b0 a0 r1 g1 b1 a1 r2 g2 b2 a2"], "type": "code"}, ".  The length of the channels determines \nthe animation length."]}, {"indent": 0, "type": "para", "text": ["The Channel SOP can also update portions of the geometry. By using point groups\nfrom the incoming op, the channels can be inserted only into the groups' points.\nTo modify only some components of a vector, use brackets to specify the \ncomponent index (", {"text": ["P(1)"], "type": "em"}, " refers to the Y value of the point position). "]}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Modify only the points within this point group. If blank, all\n    points are modified."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Group"]}, {"body": [{"indent": 4, "type": "para", "text": ["Retrieves the sample data from this CHOP."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["CHOP"]}, {"body": [{"indent": 4, "type": "para", "text": ["The sample data fetch method."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["Uses one channel for each attribute, and all points use this\n        channel (the first point resides at index 0, the next at 1,\n        and so on). The length of the channels should be at least\n        the number of points modified."]}], "indent": 4, "type": "dt", "text": ["Static"]}, {"body": [{"indent": 8, "type": "para", "text": ["Uses one channel per attribute per point. The channels show\n        the animation of each point\u2019s position/attribute values. The channels\n        must have a numeric suffix starting at zero, with at least one channel \n        for each point. For vector attributes, there should be one channel per\n        component, per point (eg. for the ", {"text": ["P"], "type": "code"}, " attribute, the channels must \n        follow the pattern ", {"text": ["tx0 ty0 tz0 tx1 ty1 tz1 tx2 ty2 tz2..."], "type": "code"}, ")."]}], "indent": 4, "type": "dt", "text": ["Animated"]}], "container": true, "type": "dt_group"}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Method"]}, {"body": [{"body": [{"indent": 5, "type": "para", "text": ["names, such as ", {"text": ["tx ty tz"], "type": "code"}, ", whereas ", {"text": ["P(1)"], "type": "code"}, " only needs one, ", {"text": ["ty"], "type": "code"}, ")."]}], "indent": 4, "type": "para", "text": ["The names of the CHOP channels that will modify the attributes. There must\n    be at least one channel name per attribute. Vector attributes may require \n    multiple channels for all components specified in the ", {"text": ["Attribute Scope"], "type": "ui"}, "  \n    (eg. an attribute scope of ", {"text": ["P"], "type": "code"}, " should have a channel scope with three "]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Channel Scope"]}, {"body": [{"indent": 4, "type": "para", "text": ["A string list of attributes to modify. For only one component of\n    an array, such as the Y value of the point position, specify the\n    number of elements in brackets (in this case, ", {"text": ["P(1)"], "type": "code"}, " would be\n    used)."]}, {"indent": 4, "type": "para", "text": ["The common attributes are:"]}, {"body": [{"body": [{"indent": 12, "tag": "td", "type": "pxml", "attrs": {}, "text": [" P"]}, {"indent": 12, "tag": "td", "type": "pxml", "attrs": {}, "text": [" Point position (X, Y, Z), 3 values"]}], "indent": 8, "tag": "tr", "type": "pxml", "attrs": {}}, {"body": [{"indent": 12, "tag": "td", "type": "pxml", "attrs": {}, "text": [" Pw"]}, {"indent": 12, "tag": "td", "type": "pxml", "attrs": {}, "text": [" Point weight, 1 value"]}], "indent": 8, "tag": "tr", "type": "pxml", "attrs": {}}, {"body": [{"indent": 12, "tag": "td", "type": "pxml", "attrs": {}, "text": [" Cd"]}, {"indent": 12, "tag": "td", "type": "pxml", "attrs": {}, "text": [" Point color (red, green, blue), 3 values"]}], "indent": 8, "tag": "tr", "type": "pxml", "attrs": {}}, {"body": [{"indent": 12, "tag": "td", "type": "pxml", "attrs": {}, "text": [" Alpha"]}, {"indent": 12, "tag": "td", "type": "pxml", "attrs": {}, "text": [" Point alpha, 1 value"]}], "indent": 8, "tag": "tr", "type": "pxml", "attrs": {}}, {"body": [{"indent": 12, "tag": "td", "type": "pxml", "attrs": {}, "text": [" N"]}, {"indent": 12, "tag": "td", "type": "pxml", "attrs": {}, "text": [" Point normal value (X, Y, Z), 3 values"]}], "indent": 8, "tag": "tr", "type": "pxml", "attrs": {}}, {"body": [{"indent": 12, "tag": "td", "type": "pxml", "attrs": {}, "text": [" uv"]}, {"indent": 12, "tag": "td", "type": "pxml", "attrs": {}, "text": [" Point texture coordinates (U,V,W), 3 values"]}], "indent": 8, "tag": "tr", "type": "pxml", "attrs": {}}], "indent": 4, "tag": "table", "type": "pxml", "attrs": {}}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Attribute Scope"]}, {"body": [{"indent": 4, "type": "para", "text": ["(Applies to 'Animated Method' only.)\n    Will reorganize the fetched channels by the value of this\n    attribute. A common example is the ", {"text": ["id"], "type": "code"}, " attribute found in\n    particles. A channel is built for each unique id since the\n    number of points may vary."]}], "indent": 0, "text": ["Organize by Attribute"], "role": "item", "attrs": {"id": "organize"}, "type": "parameters_item"}], "container": true, "role": "item_group", "type": "parameters_item_group"}], "indent": 0, "level": 1, "text": "Parameters", "role": "section", "container": true, "type": "parameters_section", "id": "parameters"}], "summary": ["Reads sample data from a chop and converts it into point positions\nand point attributes."], "type": "root", "attrs": {"version": null, "tags": "tech, anim, channel", "namespace": null, "internal": "channel", "context": "sop", "type": "node", "icon": "NETWORKS/chop"}, "title": ["Channel"]}