{"body": [{"indent": 0, "text": ["VDB Combine"], "type": "title", "level": 0}, {"indent": 0, "type": "summary", "text": ["Combines the values of two aligned VDB volumes in various ways."]}, {"type": "para", "indent": 0, "text": ["See ", {"_hs_sc": true, "text": ["volumes"], "value": "/model/volumes", "fullpath": "/model/volumes", "scheme": null, "type": "link"}, " for an explanation of standard volumes and OpenVDB volumes."]}, {"indent": 0, "type": "para", "text": ["The ", {"_hs_sc": true, "text": ["Volume Mix SOP"], "value": "/nodes/sop/volumemix", "fullpath": "/nodes/sop/volumemix", "scheme": "Node", "type": "link"}, " also works on VDBs.\nHowever, Volume Mix only operates on the \"active\" area of the destination\nvolume.\nThat is, it will only update the \"non-empty\" voxels in the destination VDB.\nTo get a true union of two disjoint VDB volumes, you must use this node."]}, {"body": [{"body": [{"indent": 4, "type": "para", "text": ["The VDBs you want to combine must match in voxel size and orientation or the results won\u2019t make sense.\n    You can use ", {"_hs_sc": true, "text": ["VDB Resample"], "value": "/nodes/sop/vdbresample", "fullpath": "/nodes/sop/vdbresample", "scheme": "Node", "type": "link"}, " to match the size/orientation of one of the VDBs to the other before combining."]}], "indent": 0, "role": "item", "type": "note"}], "container": true, "role": "item_group", "type": "note_group"}, {"body": [{"indent": 0, "type": "para", "text": ["See ", {"_hs_sc": true, "fragment": "#group", "text": ["specifying volumes"], "value": "/model/volumes#group", "fullpath": "/model/volumes#group", "scheme": null, "type": "link"}, "."]}, {"body": [{"body": [{"indent": 4, "type": "para", "text": ["The volume primitives to be used from the first input."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Group A"]}, {"body": [{"indent": 4, "type": "para", "text": ["The volume primitives to merge in from the second input."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Group B"]}, {"body": [{"indent": 4, "type": "para", "text": ["Requires that there is only one VDB in the A group.  Every VDB\n    in the B group will, in turn, be combined with the VDB in\n    the A group.  This can flatten a large collection of VDBs into\n    a single VDB."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Flatten All B into A"]}, {"body": [{"indent": 4, "type": "para", "text": ["If disabled, each VDB in the A group will be combined with\n    the first VDB in the B group.  If enabled, the combination\n    will be done pairwise."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Combine A/B Pairs"]}, {"body": [{"indent": 4, "type": "para", "text": ["Each voxel that is active in either of the input grids\n    will be processed with this operation."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["Use ", {"text": ["A"], "type": "code"}, ", ignore ", {"text": ["B"], "type": "code"}, "."]}], "indent": 4, "type": "dt", "text": ["Copy A"]}, {"body": [{"indent": 8, "type": "para", "text": ["Use ", {"text": ["B"], "type": "code"}, ", ignore ", {"text": ["A"], "type": "code"}, "."]}], "indent": 4, "type": "dt", "text": ["Copy B"]}, {"body": [{"indent": 8, "type": "para", "text": ["Use ", {"text": ["0 - A"], "type": "code"}]}], "indent": 4, "type": "dt", "text": ["Invert A"]}, {"body": [{"indent": 8, "type": "para", "text": ["Add the values of ", {"text": ["A"], "type": "code"}, " and ", {"text": ["B"], "type": "code"}, "."]}, {"body": [{"body": [{"indent": 12, "type": "para", "text": ["Using this for fog volumes (ie. density values betwen 0 and 1)"]}], "indent": 8, "role": "item", "type": "note"}], "container": true, "role": "item_group", "type": "note_group"}, {"indent": 8, "type": "para", "text": ["will push density values over 1.0, which causes a bright interface\n        between the input volumes when rendered. Try using the\n        ", {"text": ["A + (1 - A) * B"], "type": "code"}, " operation to avoid this."]}], "indent": 4, "type": "dt", "text": ["Add"]}, {"body": [{"indent": 8, "type": "para", "text": ["Subtract the values of ", {"text": ["B"], "type": "code"}, " from the values of ", {"text": ["A"], "type": "code"}, "."]}], "indent": 4, "type": "dt", "text": ["Subtract"]}, {"body": [{"indent": 8, "type": "para", "text": ["Multiply the values of ", {"text": ["A"], "type": "code"}, " and ", {"text": ["B"], "type": "code"}, "."]}], "indent": 4, "type": "dt", "text": ["Multiply"]}, {"body": [{"indent": 8, "type": "para", "text": ["Divide the values of ", {"text": ["A"], "type": "code"}, " by ", {"text": ["B"], "type": "code"}, "."]}], "indent": 4, "type": "dt", "text": ["Divide"]}, {"body": [{"indent": 8, "type": "para", "text": ["Use the maximum of each corresponding value from ", {"text": ["A"], "type": "code"}, " and ", {"text": ["B"], "type": "code"}, "."]}, {"body": [{"body": [{"indent": 12, "type": "para", "text": ["Using this for fog volumes (ie. density values betwen 0 and 1)"]}], "indent": 8, "role": "item", "type": "note"}], "container": true, "role": "item_group", "type": "note_group"}, {"indent": 8, "type": "para", "text": ["can produce a dark interface between the inputs when rendered due to\n        the binary nature of choosing a value from either from ", {"text": ["A"], "type": "code"}, " or ", {"text": ["B"], "type": "code"}, ".\n        To avoid this problem, try using the ", {"text": ["(1 - A) * B"], "type": "code"}, " operation."]}], "indent": 4, "type": "dt", "text": ["Maximum"]}, {"body": [{"indent": 8, "type": "para", "text": ["Use the minimum of each corresponding value from ", {"text": ["A"], "type": "code"}, " and ", {"text": ["B"], "type": "code"}, "."]}], "indent": 4, "type": "dt", "text": ["Minimum"]}, {"body": [{"indent": 8, "type": "para", "text": ["This is similar to ", {"text": ["SDF Difference"], "type": "code"}, " except for fog volumes. It can also\n        be viewed as \"soft cut out\" operation. Typically used to clear out an\n        area around characters in a dust simulation or some other environmental\n        volume."]}], "indent": 4, "type": "dt", "text": [{"text": ["(1 - A) * B"], "type": "code"}]}, {"body": [{"indent": 8, "type": "para", "text": ["This is similar to ", {"text": ["SDF Union"], "type": "code"}, " except for fog volumes. It can also be\n        viewed as a \"soft union\" or \"merge\" operation. Consider using this over\n        the ", {"text": ["Maximum"], "type": "code"}, " or ", {"text": ["Add"], "type": "code"}, " operations for fog volumes."]}], "indent": 4, "type": "dt", "text": [{"text": ["A + (1 - A) * B"], "type": "code"}]}, {"body": [{"indent": 8, "type": "para", "text": ["Generate the union of signed distance fields A and B."]}], "indent": 4, "type": "dt", "text": ["SDF Union"]}, {"body": [{"indent": 8, "type": "para", "text": ["Generate the intersection of signed distance fields A and B."]}], "indent": 4, "type": "dt", "text": ["SDF Intersection"]}, {"body": [{"indent": 8, "type": "para", "text": ["Remove signed distance field B from signed distance field A."]}], "indent": 4, "type": "dt", "text": ["SDF Difference"]}, {"body": [{"indent": 8, "type": "para", "text": ["Copy the active voxels of B into A."]}], "indent": 4, "type": "dt", "text": ["Replace A with Active B"]}, {"body": [{"indent": 8, "type": "para", "text": ["Make voxels active which are active in both A ", {"text": ["or"], "type": "em"}, " B."]}], "indent": 4, "type": "dt", "text": ["Activity Union"]}, {"body": [{"indent": 8, "type": "para", "text": ["Each voxel\u2019s active state is set to whether it is active in both A\n        ", {"text": ["and"], "type": "em"}, " B. This operation may deactivate voxels so it is recommended to\n        enable pruning when using this."]}], "indent": 4, "type": "dt", "text": ["Activity Intersection"]}, {"body": [{"indent": 8, "type": "para", "text": ["Each voxel\u2019s active state is set to ", {"text": ["on"], "type": "strong"}, " if is active in A but not B.\n        Otherwise, the voxel is made inactive.  It is recommended to enable\n        pruning when using this."]}], "indent": 4, "type": "dt", "text": ["Activity Difference"]}], "container": true, "type": "dt_group"}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Operation"]}, {"body": [{"indent": 4, "type": "para", "text": ["Scale values in the first field by this amount before the operation."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["A Multiplier"]}, {"body": [{"indent": 4, "type": "para", "text": ["Scale values in the second field by this amount before the operation."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["B Multiplier"]}, {"body": [{"indent": 4, "type": "para", "text": ["If the A and B VDB grids have different transforms, one grid should\n    be resampled to match the other before the two are combined.\n    Also, level set grids should have matching background values\n    (i.e., matching narrow band widths)."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Resample"]}, {"body": [{"indent": 4, "type": "para", "text": ["Specify the type of interpolation to be used when resampling."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Interpolation"]}, {"body": [{"indent": 4, "type": "para", "text": ["Deactivate active output voxels whose values equal the output grid\u2019s\n    background value.  Voxel values are considered equal if they differ by less\n    than the specified tolerance."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Deactivate Tolerance"]}, {"body": [{"indent": 4, "type": "para", "text": ["After building the VDB grid there may be undetected constant tiles.\n    This tolerance is used to detect constant regions and collapse them.\n    Such areas that are within the background value will also be marked\n    inactive."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Prune Tolerance"]}, {"body": [{"indent": 4, "type": "para", "text": ["Tests areas of inactive background values to determine if they\n    are inside or outside of an SDF, and hence whether they should\n    have negative or positive sign."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Signed-Flood-Fill Output"]}], "container": true, "role": "item_group", "type": "parameters_item_group"}], "indent": 0, "level": 1, "text": "Parameters", "role": "section", "container": true, "type": "parameters_section", "id": "parameters"}, {"body": [{"body": [{"indent": 0, "blevel": 2, "type": "bullet", "text": [{"_hs_sc": true, "text": "", "value": "/nodes/sop/volumevop", "fullpath": "/nodes/sop/volumevop", "scheme": "Node", "type": "link"}]}, {"indent": 0, "blevel": 2, "type": "bullet", "text": [{"_hs_sc": true, "text": "", "value": "/nodes/sop/volumemix", "fullpath": "/nodes/sop/volumemix", "scheme": "Node", "type": "link"}]}], "container": true, "type": "bullet_group"}], "indent": 0, "level": 1, "text": "Related", "role": "section", "container": true, "type": "related_section", "id": "related"}], "title": ["VDB Combine"], "summary": ["Combines the values of two aligned VDB volumes in various ways."], "attrs": {"version": null, "tags": "vdb, volumemix, vdbresample", "namespace": null, "internal": "vdbcombine", "context": "sop", "type": "node", "icon": "COMMON/openvdb"}, "included": ["/nodes/sop/volume_types.txt"], "type": "root"}