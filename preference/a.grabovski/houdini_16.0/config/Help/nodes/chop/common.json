{"body": [{"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["The alignment option to use."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["Find the earliest start and latest end, and extend all\n        inputs to that range using the extend conditions."]}], "indent": 4, "type": "dt", "text": ["Extend to Min/Max"]}, {"body": [{"indent": 8, "type": "para", "text": ["Find the earliest start and latest end, and stretch every\n        channel\u2019s start and end to that range."]}], "indent": 4, "type": "dt", "text": ["Stretch to Min/Max"]}, {"body": [{"indent": 8, "type": "para", "text": ["Find the earliest start and shift all channels so they all\n        start at that index. All channels are extended to the length\n        of the longest one."]}], "indent": 4, "type": "dt", "text": ["Shift to Minimum"]}, {"body": [{"indent": 8, "type": "para", "text": ["Find the latest end and shift all channels so they all end\n        at that index. Extend all channels to the length of the\n        longest one."]}], "indent": 4, "type": "dt", "text": ["Shift to Maximum"]}, {"body": [{"indent": 8, "type": "para", "text": ["Shift all channels to the start of the first channel and\n        sample all inputs using the first input\u2019s range."]}], "indent": 4, "type": "dt", "text": ["Shift to First Interval"]}, {"body": [{"indent": 8, "type": "para", "text": ["Trim all channels to first channel\u2019s range."]}], "indent": 4, "type": "dt", "text": ["Trim to First Interval"]}, {"body": [{"indent": 8, "type": "para", "text": ["Stretch all channels to the first channel\u2019s range."]}], "indent": 4, "type": "dt", "text": ["Stretch to First Interval"]}, {"body": [{"indent": 8, "type": "para", "text": ["Trim all channels to the smallest start/end interval. The\n        start and end values may not come from the same channel."]}], "indent": 4, "type": "dt", "text": ["Trim to Smallest Interval"]}, {"body": [{"indent": 8, "type": "para", "text": ["Stretch all channels to the smallest start/end interval. The\n        start and end values may not come from the same channel."]}], "indent": 4, "type": "dt", "text": ["Stretch to Smallest Interval"]}], "container": true, "type": "dt_group"}], "indent": 0, "type": "dt", "text": ["Align"]}, {"body": [{"indent": 4, "type": "para", "text": ["Specifies the range of data to generate."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["All of the animated range."]}], "indent": 4, "type": "dt", "text": ["Use Full Animation Range"]}, {"body": [{"indent": 8, "type": "para", "text": ["Only the sample at the current frame."]}], "indent": 4, "type": "dt", "text": ["Use Current Frame"]}, {"body": [{"indent": 8, "type": "para", "text": ["The range is specified from the ", {"text": ["Start"], "type": "ui"}, " and ", {"text": ["End"], "type": "ui"}, "\n        parameters."]}], "indent": 4, "type": "dt", "text": ["Use Start/End"]}, {"body": [{"indent": 8, "type": "para", "text": ["The range is taken from range of keys available in the\n        evaluated Value parameters."]}], "indent": 4, "type": "dt", "text": ["Use Value Animation"]}], "container": true, "type": "dt_group"}], "indent": 0, "type": "dt", "text": ["Range"]}, {"body": [{"indent": 4, "type": "para", "text": ["The start time of the channel range."]}], "indent": 0, "type": "dt", "attrs": {"channels": "/start"}, "text": ["Start"]}, {"body": [{"indent": 4, "type": "para", "text": ["The end time of the channel range."]}], "indent": 0, "type": "dt", "attrs": {"channels": "/end"}, "text": ["End"]}, {"body": [{"indent": 4, "type": "para", "text": ["The sample rate of the CHOP."]}], "indent": 0, "type": "dt", "attrs": {"channels": "/rate"}, "text": ["Sample Rate"]}, {"body": [{"indent": 4, "type": "para", "text": ["The number of separate threads to use to evaluate the channel samples.\n    The default is no threading."]}, {"indent": 4, "type": "para", "text": ["Since Houdini evaluates the VEX program for each sample in the input\n    geometry, it can benefit greatly from threading on a multi-processor\n    or multi-core machine when the CHOP nodes have many samples."]}], "indent": 0, "type": "dt", "text": ["Number of Threads"]}], "container": true, "type": "dt_group"}], "indent": 0, "level": 2, "text": ["Channel"], "container": true, "type": "h", "id": "channel"}, {"body": [{"indent": 0, "type": "para", "text": ["Some of these parameters may not be available on all CHOP nodes."]}, {"body": [{"body": [{"indent": 4, "type": "para", "text": ["To determine which channels get affected, some CHOPs have a scope string. Patterns can be used in the scope, for example ", {"text": ["*"], "type": "code"}, " (match all), and ", {"text": ["?"], "type": "code"}, " (match single character). "]}, {"indent": 4, "type": "para", "text": ["The following are examples of possible channel name matching options:"]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["Matches a single channel name."]}], "indent": 4, "type": "dt", "text": [{"text": ["chan2"], "type": "code"}]}, {"body": [{"indent": 8, "type": "para", "text": ["Matches four channel names, separated by spaces."]}], "indent": 4, "type": "dt", "text": [{"text": ["chan3 tx ty tz"], "type": "code"}]}, {"body": [{"indent": 8, "type": "para", "text": ["Matches each channel that starts with ", {"text": ["chan"], "type": "code"}, "."]}], "indent": 4, "type": "dt", "text": [{"text": ["chan*"], "type": "code"}]}, {"body": [{"indent": 8, "type": "para", "text": ["Matches each channel that has ", {"text": ["foot"], "type": "code"}, " in it."]}], "indent": 4, "type": "dt", "text": [{"text": ["*foot*"], "type": "code"}]}, {"body": [{"indent": 8, "type": "para", "text": ["The ", {"text": ["?"], "type": "code"}, " matches a single character. ", {"text": ["t?"], "type": "code"}, " matches two-character channels starting with t.  "]}], "indent": 4, "type": "dt", "text": [{"text": ["t?"], "type": "code"}]}, {"body": [{"indent": 8, "type": "para", "text": ["Matches channels ", {"text": ["rx"], "type": "code"}, ", ", {"text": ["ry"], "type": "code"}, " and ", {"text": ["rz"], "type": "code"}, "."]}], "indent": 4, "type": "dt", "text": [{"text": ["r[xyz]"], "type": "code"}]}, {"body": [{"indent": 8, "type": "para", "text": ["Matches number ranges giving ", {"text": ["blend3"], "type": "code"}, ", ", {"text": ["blend5"], "type": "code"}, ", and ", {"text": ["blend7"], "type": "code"}, "."]}], "indent": 4, "type": "dt", "text": [{"text": ["blend[3-7:2]"], "type": "code"}]}, {"body": [{"indent": 8, "type": "para", "text": ["Matches channels ", {"text": ["blend2"], "type": "code"}, ", ", {"text": ["blend3"], "type": "code"}, ", ", {"text": ["blend5"], "type": "code"}, ", ", {"text": ["blend13"], "type": "code"}, "."]}], "indent": 4, "type": "dt", "text": [{"text": ["blend[2-3,5,13]"], "type": "code"}]}, {"body": [{"indent": 8, "type": "para", "text": [{"text": ["[xyz]"], "type": "code"}, "matches three characters, giving channels ", {"text": ["tx"], "type": "code"}, ", ", {"text": ["ty"], "type": "code"}, " and ", {"text": ["tz"], "type": "code"}, "."]}], "indent": 4, "type": "dt", "text": [{"text": ["t[xyz]"], "type": "code"}]}], "container": true, "type": "dt_group"}], "indent": 0, "type": "dt", "text": ["Scope"]}, {"body": [{"indent": 4, "type": "para", "text": ["The Sample Rate Match Options handle cases where multiple input CHOPs\u2019 sample rates are different."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["Use rate of first input to resample others."]}], "indent": 4, "type": "dt", "text": ["Resample At First Input\u2019s Rate"]}, {"body": [{"indent": 8, "type": "para", "text": ["Resample to highest sample rate."]}], "indent": 4, "type": "dt", "text": ["Resample At Maximum Rate"]}, {"body": [{"indent": 8, "type": "para", "text": ["Resample to the lowest sample rate."]}], "indent": 4, "type": "dt", "text": ["Resample At Minimum Rate"]}, {"body": [{"indent": 8, "type": "para", "text": ["Does not accept conflicting sample rates."]}], "indent": 4, "type": "dt", "text": ["Error if Rates Differ"]}], "container": true, "type": "dt_group"}], "indent": 0, "type": "dt", "text": ["Sample Rate Match"]}, {"body": [{"indent": 4, "type": "para", "text": ["The units for which time parameters are specified."]}, {"indent": 4, "type": "para", "text": ["For example, you can specify the amount of time a lag should last for in seconds (default), frames (at the Houdini FPS), or samples (in the CHOP\u2019s sample rate)."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["When you change the Units parameter, it does not convert the existing parameters to the new units."]}], "indent": 4, "role": "item", "type": "note"}], "container": true, "role": "item_group", "type": "note_group"}], "indent": 0, "type": "dt", "text": ["Units"]}, {"body": [{"indent": 4, "type": "para", "text": ["Time Slicing is a feature which boosts cooking performance and reduces memory usage. Traditionally, CHOPs calculate the channel over its entire frame range. If the channel does need to be evaluated every frame, then cooking the entire range of the channel is unnecessary. It is more efficient to calculate only the fraction of the channel that is needed. This fraction is known as a Time Slice."]}], "indent": 0, "type": "dt", "text": ["Time Slice"]}, {"body": [{"indent": 4, "type": "para", "text": ["Causes the memory consumed by a CHOP to be released after it is cooked and the data passed to the next CHOP."]}], "indent": 0, "type": "dt", "text": ["Unload"]}, {"body": [{"indent": 4, "type": "para", "text": ["The Export prefix is prepended to CHOP channel names to determine where to export to. "]}, {"indent": 4, "type": "para", "text": ["For example, if the CHOP channel was named ", {"text": ["geo1:tx"], "type": "code"}, ", and the prefix was ", {"text": ["/obj"], "type": "code"}, ", the channel would be exported to ", {"text": ["/obj/geo1/tx"], "type": "code"}, "."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["You can leave the ", {"text": ["Export Prefix"], "type": "ui"}, " blank, but then your CHOP track names need to be absolute paths, such as ", {"text": ["obj:geo1:tx"], "type": "code"}, "."]}], "indent": 4, "role": "item", "type": "note"}], "container": true, "role": "item_group", "type": "note_group"}], "indent": 0, "type": "dt", "text": ["Export Prefix"]}, {"body": [{"indent": 4, "type": "para", "text": ["Every CHOP has this option. Each CHOP gets a default color assigned for display in the Graph port, but you can override the color in the Common page under Graph Color. There are 36 RGB color combinations in the Palette."]}], "indent": 0, "type": "dt", "text": ["Graph Color"]}, {"body": [{"indent": 4, "type": "para", "text": ["When the graph displays the animation curves and a CHOP has two or more channels, this defines the difference in color from one channel to the next, giving a rainbow spectrum of colors."]}], "indent": 0, "type": "dt", "text": ["Graph Color Step"]}], "container": true, "type": "dt_group"}], "indent": 0, "level": 2, "text": ["Common"], "container": true, "type": "h", "id": "common"}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["The left menu chooses the order in which transforms are applied. For example: scale, then rotate, then move. This can change the position and orientation of the object, in the same way that going a block and turning east takes you to a different place than turning east and then going a block."]}, {"indent": 4, "type": "para", "text": ["The right menu chooses the order in which to rotate around the X, Y, and Z axes. Certain orders can make character joint transforms easier to use, depending on the character."]}], "indent": 0, "type": "dt", "attrs": {"id": "xord"}, "text": ["Transform Order"]}], "container": true, "type": "dt_group"}], "indent": 0, "level": 2, "text": ["Transform Order"], "container": true, "type": "h", "id": "transformorder"}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Translation along XYZ axes."]}], "indent": 0, "type": "dt", "attrs": {"id": "t"}, "text": ["Translate"]}, {"body": [{"indent": 4, "type": "para", "text": ["Degrees rotation about XYZ axes."]}], "indent": 0, "type": "dt", "attrs": {"id": "r"}, "text": ["Rotation"]}, {"body": [{"indent": 4, "type": "para", "text": ["Non-uniform scaling about XYZ axes."]}], "indent": 0, "type": "dt", "attrs": {"id": "s"}, "text": ["Scale"]}], "container": true, "type": "dt_group"}], "indent": 0, "level": 2, "text": ["Transform"], "container": true, "type": "h", "id": "transform"}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Local origin of the object.\n    See also ", {"_hs_sc": true, "text": ["setting the pivot point"], "value": "/basics/objects", "fullpath": "/basics/objects", "scheme": null, "type": "link"}, " ."]}], "indent": 0, "type": "dt", "attrs": {"id": "p"}, "text": ["Pivot"]}], "container": true, "type": "dt_group"}], "indent": 0, "level": 2, "text": ["Transform Pivot"], "container": true, "type": "h", "id": "transformpivot"}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Rotation channels typically don\u2019t blend well when treated as Euler angles, and straight linear blending can result in flips and odd rotations. Instead, shortest path blending can be used to properly blend orientations represented by Euler rotation angles."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["Rotation channels are blended like any other channel."]}], "indent": 4, "type": "dt", "text": ["Euler"]}, {"body": [{"indent": 8, "type": "para", "text": ["Two inputs are blended using shortest path rotation blending. If more than two blend inputs are connected, use ", {"text": ["Fast Linear"], "type": "ui"}, "."]}], "indent": 4, "type": "dt", "text": ["Shortest Path (Linear)"]}, {"body": [{"indent": 8, "type": "para", "text": ["Multiple inputs are blended together using shortest path rotation blending."]}], "indent": 4, "type": "dt", "text": ["Shortest Path (Fast Linear)"]}], "container": true, "type": "dt_group"}], "indent": 0, "type": "dt", "text": ["Rotation Blending"]}], "container": true, "type": "dt_group"}], "indent": 0, "level": 2, "text": ["Rotation Blending3"], "container": true, "type": "h", "id": "rotblend3"}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Rotation channels typically don\u2019t blend well when treated as Euler angles, and straight linear blending can result in flips and odd rotations. Instead, shortest path blending can be used to properly blend orientations represented by Euler rotation angles."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["Rotation channels are blended like any other channel."]}], "indent": 4, "type": "dt", "text": ["Euler"]}, {"body": [{"indent": 8, "type": "para", "text": ["Two inputs are blended using shortest path rotation blending."]}], "indent": 4, "type": "dt", "text": ["Shortest Path"]}], "container": true, "type": "dt_group"}], "indent": 0, "type": "dt", "text": ["Rotation Blending"]}], "container": true, "type": "dt_group"}], "indent": 0, "level": 2, "text": ["Rotation Blending2"], "container": true, "type": "h", "id": "rotblend2"}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Define which of the transform components (TX,TY,TZ,RX,RY,RZ,SX,SY,SZ) to blend."]}], "indent": 0, "type": "dt", "attrs": {"id": "mask"}, "text": ["Mask"]}], "container": true, "type": "dt_group"}], "indent": 0, "level": 2, "text": ["Blend Mask"], "container": true, "type": "h", "id": "blendmask"}], "type": "root", "attrs": {"type": "include"}}