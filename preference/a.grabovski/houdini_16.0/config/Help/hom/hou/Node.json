{"body": [{"indent": 0, "text": [{"text": "hou.", "type": "supertitle"}, "Node"], "type": "title", "level": 0}, {"indent": 0, "type": "summary", "text": ["The base class for all nodes in Houdini (objects, SOPs, COPs, etc.)  An instance of this class corresponds to exactly one instance of a node in Houdini."]}, {"indent": 0, "type": "para", "text": ["Each node has a unique path that defines its location in the tree of nodes.\nThe node path hierarchy is similar to the hierarchy of folders and files in a\nfile system.  Some nodes, called networks, may contain other nodes inside them,\nmuch like a file folder would, while other nodes may not.  For example, an\nobject node instance and a SOP subnetwork node instance may contain SOP nodes,\nbut a box SOP instance may not."]}, {"body": [{"body": [{"indent": 4, "type": "para", "text": ["Be careful not to confuse nodes with node types.  A node is an instance\n    of a node type.  For example suppose ", {"text": ["/obj/geo1/box1"], "type": "code"}, " is a box SOP.  It has\n    its own unique name (box1) and its own copies of parameter values.  It is\n    an instance of the box SOP node type.  This node type defines what\n    parameters are common to all box SOP node instances, as well as the\n    algorithm that each BOX SOP performs.  The class that represents a node\n    type is ", {"_hs_sc": true, "text": "", "value": "/hom/hou/NodeType", "fallback_text": "hou.NodeType", "fullpath": "/hom/hou/NodeType", "scheme": "Hom", "type": "link"}, "."]}], "indent": 0, "role": "item", "type": "tip"}], "container": true, "role": "item_group", "type": "tip_group"}, {"indent": 0, "type": "para", "text": ["You cannot create instances of ", {"text": ["hou.Node"], "type": "code"}, " using ", {"text": ["hou.Node.__init__"], "type": "code"}, ".\nInstead, you look up Node objects corresponding to existing Houdini nodes\nwith ", {"_hs_sc": true, "text": ["hou.node()"], "value": "/hom/hou/node_", "fullpath": "/hom/hou/node_", "scheme": "Hom", "type": "link"}, ".  To create a new Houdini node instance inside another\nnode, use ", {"_hs_sc": true, "fragment": "#createNode", "text": "", "value": "/hom/hou/Node#createNode", "fallback_text": "hou.Node.createNode", "fullpath": "/hom/hou/Node#createNode", "scheme": "Hom", "type": "link"}, ".  To delete a Houdini node, use\n", {"_hs_sc": true, "fragment": "#destroy", "text": "", "value": "/hom/hou/Node#destroy", "fallback_text": "hou.Node.destroy", "fullpath": "/hom/hou/Node#destroy", "scheme": "Hom", "type": "link"}, "."]}, {"indent": 0, "type": "para", "text": ["Note that a Node object internally stores a reference to the corresponding\nHoudini node, and that their lifetimes are different.  If a Python node object\nis deleted because its reference count in Python goes to zero, the Houdini node\nwill be unaffected.  On the other hand, if you have a Node object in a Python\nvariable and the Houdini node is deleted, the Python variable will still exist,\nand Python will not crash.  Instead, if you later call a method on that\nPython Node object, Houdini will raise a ", {"_hs_sc": true, "text": "", "value": "/hom/hou/ObjectWasDeleted", "fallback_text": "hou.ObjectWasDeleted", "fullpath": "/hom/hou/ObjectWasDeleted", "scheme": "Hom", "type": "link"}, " exception."]}, {"indent": 0, "type": "para", "text": ["Be careful not to confuse this class with the function ", {"_hs_sc": true, "text": ["hou.node"], "value": "/hom/hou/node_", "fullpath": "/hom/hou/node_", "scheme": "Hom", "type": "link"}, "."]}, {"body": [{"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Return the node at the given path, or None if no such node exists.  If\n    you pass in a relative path (i.e. the path does not start with ", {"text": ["/"], "type": "code"}, "),\n    searches are performed relative to this node."]}, {"indent": 4, "type": "para", "text": ["For example, to get the parent node of a node in the the variable ", {"text": ["n"], "type": "code"}, ", use\n    ", {"text": ["n.node(\"..\")"], "type": "code"}, ". To get a child node named ", {"text": ["geo5"], "type": "code"}, ", use ", {"text": ["n.node(\"geo5\")"], "type": "code"}, ".\n    To get a sibling node named ", {"text": ["light3"], "type": "code"}, ", use ", {"text": ["n.node(\"../light3\")"], "type": "code"}, "."]}, {"indent": 4, "type": "para", "text": ["Note that the return value may be an instance of a subclass of Node. For\n    example, if the node being found is an object node, the return value\n    will be a ", {"_hs_sc": true, "text": "", "value": "/hom/hou/ObjNode", "fallback_text": "hou.ObjNode", "fullpath": "/hom/hou/ObjNode", "scheme": "Hom", "type": "link"}, " instance."]}, {"indent": 4, "type": "para", "text": ["If the path is an absolute path (i.e. it starts with ", {"text": ["/"], "type": "code"}, "), this\n    method is a shortcut for ", {"text": ["hou.node(node_path)"], "type": "code"}, ".  Otherwise, it is\n    a shortcut for ", {"text": ["hou.node(self.path() + \"/\" + node_path)"], "type": "code"}, ".  See also\n    ", {"_hs_sc": true, "text": "", "value": "/hom/hou/node_", "fallback_text": "hou.node_", "fullpath": "/hom/hou/node_", "scheme": "Hom", "type": "link"}, "."]}], "indent": 0, "text": [{"text": ["node(self, node_path)"], "type": "code"}, "  \u2192 ", {"_hs_sc": true, "text": "", "value": "/hom/hou/Node", "fallback_text": "hou.Node", "fullpath": "/hom/hou/Node", "scheme": "Hom", "type": "link"}, " or ", {"text": ["None"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::node", "replaces": "/commands/opfind /expressions/chsop /expressions/opexist /expressions/opfullpathfrom"}, "type": "methods_item", "id": "node"}, {"body": [{"indent": 4, "type": "para", "text": ["Return the network item at the given path, or None if no such item exists.\n    If you pass in a relative path (i.e. the path does not start with ", {"text": ["/"], "type": "code"}, "),\n    searches are performed relative to this node."]}, {"indent": 4, "type": "para", "text": ["If the path is an absolute path (i.e. it starts with ", {"text": ["/"], "type": "code"}, "), this\n    method is a shortcut for ", {"text": ["hou.item(node_path)"], "type": "code"}, ".  Otherwise, it is\n    a shortcut for ", {"text": ["hou.item(self.path() + \"/\" + item_path)"], "type": "code"}, ".  See also\n    ", {"_hs_sc": true, "text": "", "value": "/hom/hou/item", "fallback_text": "hou.item", "fullpath": "/hom/hou/item", "scheme": "Hom", "type": "link"}, "."]}, {"indent": 4, "type": "para", "text": ["Note that the return value may be an instance of a subclass of\n    NetworkMovableItem. For example, if the item being found is an object node,\n    the return value will be a ", {"_hs_sc": true, "text": "", "value": "/hom/hou/ObjNode", "fallback_text": "hou.ObjNode", "fullpath": "/hom/hou/ObjNode", "scheme": "Hom", "type": "link"}, " instance. If the item is a\n    nework box, the return value will be a ", {"_hs_sc": true, "text": "", "value": "/hom/hou/NetworkBox", "fallback_text": "hou.NetworkBox", "fullpath": "/hom/hou/NetworkBox", "scheme": "Hom", "type": "link"}, " instance."]}], "indent": 0, "text": [{"text": ["item(self, item_path)"], "type": "code"}, "  \u2192 ", {"_hs_sc": true, "text": "", "value": "/hom/hou/NetworkMovableItem", "fallback_text": "hou.NetworkMovableItem", "fullpath": "/hom/hou/NetworkMovableItem", "scheme": "Hom", "type": "link"}, " or ", {"text": ["None"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::item"}, "type": "methods_item", "id": "item"}, {"body": [{"indent": 4, "type": "para", "text": ["Return ", {"text": ["True"], "type": "code"}, " if this node is a network, in other words a node that may\n    contain child nodes. Otherwise return ", {"text": ["False"], "type": "code"}, " which indicates that several\n    other methods such as ", {"_hs_sc": true, "fragment": "#createNode", "text": "", "value": "/hom/hou/Node#createNode", "fallback_text": "hou.Node.createNode", "fullpath": "/hom/hou/Node#createNode", "scheme": "Hom", "type": "link"}, " will raise\n    ", {"_hs_sc": true, "text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if they are called."]}], "indent": 0, "text": [{"text": ["isNetwork(self)"], "type": "code"}, "  \u2192 ", {"text": ["bool"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::isNetwork"}, "type": "methods_item", "id": "isNetwork"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a list of nodes that are children of this node.  Using the file\n    system analogy, a node\u2019s children are like the contents of a\n    folder/directory."]}, {"indent": 4, "type": "para", "text": ["To find the number of children nodes, use ", {"text": ["len(node.children())"], "type": "code"}, "."]}, {"indent": 4, "type": "para", "text": ["The order of the children in the result is the same as the user defined\n    ordering in Houdini.  To see this order, switch the network view pane\n    into list mode, and ensure that the list order is set to ", {"text": ["user defined"], "type": "ui"}, ".\n    To reorder nodes, drag and drop them in the list."]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    def pc(node):\n        '''Print the names of the children of a particular node.  This function\n           can be handy when working interactively in the Python shell.'''\n        for child in node.children():\n            print child.name()\n\n    def ls():\n        '''Print the names of the nodes under the current node.'''\n        pc(hou.pwd())\n    "]}, {"indent": 4, "type": "para", "text": ["The following expression evaluates to a list of children of a particular\n    node type:"]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    [c for c in node.children() if c.type() == node_type]\n    "]}], "indent": 0, "text": [{"text": ["children(self)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"_hs_sc": true, "text": "", "value": "/hom/hou/Node", "fallback_text": "hou.Node", "fullpath": "/hom/hou/Node", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::children", "replaces": "/commands/opfind /commands/opls /expressions/opnchildren"}, "type": "methods_item", "id": "children"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a tuple containing all the children of this node.\n    Unlike ", {"text": ["children"], "type": "code"}, ", this method will also return\n    ", {"_hs_sc": true, "text": "", "value": "/hom/hou/NetworkBox", "fallback_text": "hou.NetworkBox", "fullpath": "/hom/hou/NetworkBox", "scheme": "Hom", "type": "link"}, ", ", {"_hs_sc": true, "text": "", "value": "/hom/hou/SubnetIndirectInput", "fallback_text": "hou.SubnetIndirectInput", "fullpath": "/hom/hou/SubnetIndirectInput", "scheme": "Hom", "type": "link"}, ",\n    ", {"_hs_sc": true, "text": "", "value": "/hom/hou/StickyNote", "fallback_text": "hou.StickyNote", "fullpath": "/hom/hou/StickyNote", "scheme": "Hom", "type": "link"}, ", and ", {"_hs_sc": true, "text": "", "value": "/hom/hou/NetworkDot", "fallback_text": "hou.NetworkDot", "fullpath": "/hom/hou/NetworkDot", "scheme": "Hom", "type": "link"}, " objects."]}], "indent": 0, "text": [{"text": ["allItems(self)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"_hs_sc": true, "text": "", "value": "/hom/hou/NetworkMovableItem", "fallback_text": "hou.NetworkMovableItem", "fullpath": "/hom/hou/NetworkMovableItem", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::allItems"}, "type": "methods_item", "id": "allItems"}, {"body": [{"indent": 4, "type": "para", "text": ["Recursively return all sub children of this node.  For example,\n    ", {"text": ["hou.node(\"/\").allSubChildren()"], "type": "code"}, " will return all the nodes in the hip\n    file."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["If True, this function will do a top-down traversal, placing a node\n        in the returned tuple before its children.  If False, it will do\n        a bottom-up traversal, placing children before their parents."]}], "indent": 4, "type": "dt", "text": ["top_down"]}], "container": true, "type": "dt_group"}, {"indent": 4, "type": "para", "text": ["Note that a tuple is returned, not a generator.  This means that it is\n    safe to delete or create nodes while looping through the return value."]}, {"indent": 4, "type": "para", "text": ["The following function deletes all children of a particular type that\n    appear anywhere inside a given node:"]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    def removeSubChildrenOfType(node, node_type):\n        '''Recursively delete all children of a particular type.'''\n        for child in node.allSubChildren():\n            if child.type() == node_type:\n                child.destroy()\n    "]}, {"indent": 4, "type": "para", "text": ["This code, for example, removes all the visibility SOPs anywhere under /obj:"]}, {"lang": "pycon", "indent": 4, "type": "pre", "text": ["\n    >>> removeSubChildrenOfType(hou.node(\"/obj\"), hou.sopNodeTypeCategory().nodeTypes()['visibility'])\n    "]}], "indent": 0, "text": [{"text": ["allSubChildren(self, top_down=True)"], "type": "code"}, "  \u2192 tuple of ", {"_hs_sc": true, "text": "", "value": "/hom/hou/Node", "fallback_text": "hou.Node", "fullpath": "/hom/hou/Node", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::allSubChildren", "replaces": "/commands/oprmtype /commands/opfind"}, "type": "methods_item", "id": "allSubChildren"}, {"body": [{"indent": 4, "type": "para", "text": ["Recursively return a sequence of all nodes contained in this node including\n    this node.  This method differs from ", {"_hs_sc": true, "fragment": "#allSubChildren", "text": "", "value": "/hom/hou/Node#allSubChildren", "fallback_text": "hou.Node.allSubChildren", "fullpath": "/hom/hou/Node#allSubChildren", "scheme": "Hom", "type": "link"}, " in the\n    following ways:"]}, {"body": [{"indent": 4, "blevel": 6, "type": "bullet", "text": ["It includes this node in the returned sequence."]}, {"indent": 4, "blevel": 6, "type": "bullet", "text": ["It does not guarantee a top-down or bottom-up traversal order."]}, {"indent": 4, "blevel": 6, "type": "bullet", "text": ["The method is a generator and does not return a tuple so it is not safe\n      to create or delete nodes while looping through the return value."]}], "container": true, "type": "bullet_group"}, {"indent": 4, "type": "para", "text": ["Here is an example of printing out the paths for all nodes under /obj:"]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    root_node = hou.node(\"/obj\")\n    for node in root_node.allNodes():\n        print node.path()\n    "]}], "indent": 0, "text": [{"text": ["allNodes(self)"], "type": "code"}, "  \u2192 generator of ", {"_hs_sc": true, "text": "", "value": "/hom/hou/Node", "fallback_text": "hou.Node", "fullpath": "/hom/hou/Node", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::allNodes"}, "type": "methods_item", "id": "allNodes"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a tuple of children nodes name matches the pattern."]}, {"indent": 4, "type": "para", "text": ["The pattern may contain multiple pieces, separated by spaces.  An asterisk\n    (", {"text": ["*"], "type": "code"}, ") in a pattern piece will match any character.  By default, Houdini\n    will add the nodes from each pattern piece to those already matched.\n    However, if the pattern piece begins with a caret (", {"text": ["^"], "type": "code"}, "), Houdini will\n    remove the matches for that piece from the result."]}, {"indent": 4, "type": "para", "text": ["By default the pattern match is case-sensitive.  Set ", {"text": ["ignore_case"], "type": "code"}, " to\n    True for case-insensitive pattern matching.  Note that case insensitivity\n    only applies when matching node names.  It does not apply when matching\n    group, network box or bundle names."]}, {"indent": 4, "type": "para", "text": ["This method returns an empty tuple if you pass in an empty pattern."]}, {"lang": "pycon", "indent": 4, "type": "pre", "text": ["\n    >>> obj = hou.node(\"/obj\")\n    >>> obj.createNode(\"geo\", \"geo1\")\n    <hou.ObjNode of type geo at /obj/geo1>\n    >>> obj.createNode(\"geo\", \"geo2\")\n    <hou.ObjNode of type geo at /obj/geo2>\n    >>> obj.createNode(\"geo\", \"grid\")\n    <hou.ObjNode of type geo at /obj/grid>\n    >>> obj.createNode(\"geo\", \"garbage\")\n    <hou.ObjNode of type geo at /obj/garbage>\n    >>> obj.createNode(\"geo\", \"box\")\n    <hou.ObjNode of type geo at /obj/box>\n\n    >>> def names(nodes):\n    ... return [node.name() for node in nodes]\n\n    >>> names(obj.glob(\"g*\"))\n    ['geo1', 'geo2', 'grid', 'garbage']\n    >>> names(obj.glob(\"ge* ga*\"))\n    ['geo1', 'geo2', 'garbage']\n    >>> names(obj.glob(\"g* ^ga*\"))\n    ['geo1', 'geo2', 'grid']\n    "]}, {"indent": 4, "type": "para", "text": ["See also ", {"_hs_sc": true, "fragment": "#recursiveGlob", "text": "", "value": "/hom/hou/Node#recursiveGlob", "fallback_text": "hou.Node.recursiveGlob", "fullpath": "/hom/hou/Node#recursiveGlob", "scheme": "Hom", "type": "link"}, "."]}], "indent": 0, "text": [{"text": ["glob(self, pattern, ignore_case=False)"], "type": "code"}, "  \u2192 tuple of ", {"_hs_sc": true, "text": "", "value": "/hom/hou/Node", "fallback_text": "hou.Node", "fullpath": "/hom/hou/Node", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::glob", "replaces": "/commands/opglob /commands/opfind"}, "type": "methods_item", "id": "glob"}, {"body": [{"indent": 4, "type": "para", "text": ["Like ", {"_hs_sc": true, "fragment": "#glob", "text": "", "value": "/hom/hou/Node#glob", "fallback_text": "hou.Node.glob", "fullpath": "/hom/hou/Node#glob", "scheme": "Hom", "type": "link"}, ", return a tuple of children nodes whose name\n    matches the pattern.  However, any matching child will have all its children\n    added, recursively.  As well, the result may be filtered by node type."]}, {"indent": 4, "type": "para", "text": ["Houdini first matches children nodes against the pattern, then recursively\n    adds the subchildren of matching children, and then applies the filter."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["Child node names will be matched against this string pattern.  See\n        ", {"_hs_sc": true, "fragment": "#glob", "text": "", "value": "/hom/hou/Node#glob", "fallback_text": "hou.Node.glob", "fullpath": "/hom/hou/Node#glob", "scheme": "Hom", "type": "link"}, " and ", {"_hs_sc": true, "text": "", "value": "/hom/hou/NodeBundle", "fallback_text": "hou.NodeBundle", "fullpath": "/hom/hou/NodeBundle", "scheme": "Hom", "type": "link"}, " for information about the\n        pattern syntax.  Note that if a child node matches the pattern, all of\n        its subchildren will be added to the result (subject to filtering),\n        regardless of the pattern."]}], "indent": 4, "type": "dt", "text": [{"text": ["pattern"], "type": "code"}]}, {"body": [{"indent": 8, "type": "para", "text": ["A ", {"_hs_sc": true, "text": "", "value": "/hom/hou/nodeTypeFilter", "fallback_text": "hou.nodeTypeFilter", "fullpath": "/hom/hou/nodeTypeFilter", "scheme": "Hom", "type": "link"}, " enumeration value to limit matched nodes\n        to a particular type (e.g. object nodes, geometry object nodes,\n        surface shader SHOPs, etc.)."]}], "indent": 4, "type": "dt", "text": [{"text": ["filter"], "type": "code"}]}], "container": true, "type": "dt_group"}, {"indent": 4, "type": "para", "text": ["The pattern and filter behavior is very similar to that used by node\n    bundles in Houdini.  See ", {"_hs_sc": true, "text": "", "value": "/hom/hou/NodeBundle", "fallback_text": "hou.NodeBundle", "fullpath": "/hom/hou/NodeBundle", "scheme": "Hom", "type": "link"}, " for more information."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"_hs_sc": true, "text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if the pattern is invalid."]}], "indent": 0, "text": [{"text": ["recursiveGlob(self, pattern, filter=hou.nodeTypeFilter.NoFilter)"], "type": "code"}, "  \u2192 tuple of ", {"_hs_sc": true, "text": "", "value": "/hom/hou/Node", "fallback_text": "hou.Node", "fullpath": "/hom/hou/Node", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::recursiveGlob", "replaces": "/commands/opglob /commands/opfind"}, "type": "methods_item", "id": "recursiveGlob"}], "container": true, "role": "item_group", "type": "methods_item_group"}], "indent": 0, "level": 2, "text": ["Hierarchy"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Create a new node of type ", {"text": ["node_type_name"], "type": "code"}, " as a child of this node."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["The name of the new node. If not specified, Houdini appends a number\n        to the node type name, incrementing that number until a unique node\n        name is found.  If you specify a name and a node already exists with\n        that name, Houdini will append a number to create a unique name."]}], "indent": 4, "type": "dt", "text": [{"text": ["node_name"], "type": "code"}]}, {"body": [{"indent": 8, "type": "para", "text": ["If True, the initialization script associated with the node type will\n        be run on the new node."]}], "indent": 4, "type": "dt", "text": [{"text": ["run_init_scripts"], "type": "code"}]}, {"body": [{"indent": 8, "type": "para", "text": ["If True, any subnet contents will be loaded for custom subnet\n        operators."]}], "indent": 4, "type": "dt", "text": [{"text": ["load_contents"], "type": "code"}]}, {"body": [{"indent": 8, "type": "para", "text": ["If True, the node\u2019s type name will be exactly as specified in the\n        ", {"text": ["node_type_name"], "type": "code"}, ". Otherwise, a preferred operator type that matches\n        the given ", {"text": ["node_type_name"], "type": "code"}, " may be used. For example, the given \"hda\"\n        may match a newer version \"hda::2.0\", or if there are two available\n        operators \"namespaceA::hda\" and \"namespaceB::hda\", and the \"namespaceB\"\n        has precedence, then the created node will be of type \"namespaceB::hda\"."]}], "indent": 4, "type": "dt", "text": [{"text": ["exact_type_name"], "type": "code"}]}], "container": true, "type": "dt_group"}, {"indent": 4, "type": "para", "text": ["Raises ", {"_hs_sc": true, "text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if this node cannot contain children.\n    Raises ", {"_hs_sc": true, "text": "", "value": "/hom/hou/PermissionError", "fallback_text": "hou.PermissionError", "fullpath": "/hom/hou/PermissionError", "scheme": "Hom", "type": "link"}, " if this node is inside a locked asset."]}, {"lang": "pycon", "indent": 4, "type": "pre", "text": ["\n    >>> obj = hou.node(\"/obj\")\n\n    # Let Houdini choose a name based on the node type name.\n    >>> obj.createNode(\"geo\")\n    <hou.ObjNode of type geo at /obj/geo1>\n\n    # Let Houdini choose a unique name.\n    >>> obj.createNode(\"geo\")\n    <hou.ObjNode of type geo at /obj/geo2>\n\n    # Give the node a specific name.\n    >>> obj.createNode(\"geo\", \"foo\")\n    <hou.ObjNode of type geo at /obj/foo>\n\n    # Let Houdini create a unique name from our suggested name.  Also, don't\n    # run the geometry object init scripts so the contents are empty.\n    >>> obj.createNode(\"geo\", \"geo1\", run_init_scripts=False)\n    <hou.ObjNode of type geo at /obj/geo3>\n    >>> obj.node(\"geo1\").children()\n    (<hou.SopNode of type file at /obj/geo1/file1>,)\n    >>> obj.node(\"geo3\").children()\n    ()\n    "]}], "indent": 0, "text": [{"text": ["createNode(self, node_type_name, node_name=None, run_init_scripts=True, load_contents=True, exact_type_name=False)"], "type": "code"}, "  \u2192 ", {"_hs_sc": true, "text": "", "value": "/hom/hou/Node", "fallback_text": "hou.Node", "fullpath": "/hom/hou/Node", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::createNode", "replaces": "/commands/opadd"}, "type": "methods_item", "id": "createNode"}, {"body": [{"indent": 4, "type": "para", "text": ["Creates a node for visualizing the data from a particular output of this\n    node. If a visualizer node already exists in the current network, it is\n    moved and connected to the specified ", {"text": ["output_index"], "type": "code"}, ". This method is only\n    implemented for SOP and VOP nodes. Other node types do nothing when\n    this method is called."]}], "indent": 0, "text": [{"text": ["createOrMoveVisualizer(self, output_index)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::createOrMoveVisualizer"}, "type": "methods_item", "id": "createOrMoveVisualizer"}, {"body": [{"indent": 4, "type": "para", "text": ["Delete this node."]}, {"indent": 4, "type": "para", "text": ["If you call methods on a Node instance after it has been destroyed, Houdini\n    will raise ", {"_hs_sc": true, "text": "", "value": "/hom/hou/ObjectWasDeleted", "fallback_text": "hou.ObjectWasDeleted", "fullpath": "/hom/hou/ObjectWasDeleted", "scheme": "Hom", "type": "link"}, "."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"_hs_sc": true, "text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if you try to delete a node inside a\n    locked asset."]}], "indent": 0, "text": [{"text": ["destroy(self)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::destroy", "replaces": "/commands/oprm"}, "type": "methods_item", "id": "destroy"}, {"body": [{"indent": 4, "type": "para", "text": ["Create copies of all specified items in this network. The items do not\n    need to be children of this network, but all items must be contained in\n    the same parent network."]}, {"indent": 4, "type": "para", "text": ["If ", {"text": ["channel_reference_originals"], "type": "code"}, " is True, the parameters of all new nodes\n    are set to channel reference the original nodes. If a copied node is a\n    sub-network, only the top level node establishes channel references to the\n    original. Child nodes inside the sub-network will be simple copies of the\n    original child nodes."]}, {"indent": 4, "type": "para", "text": ["Returns a ", {"text": ["tuple"], "type": "code"}, " of all the new network items."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"_hs_sc": true, "text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if this node cannot contain children.\n    Raises ", {"_hs_sc": true, "text": "", "value": "/hom/hou/PermissionError", "fallback_text": "hou.PermissionError", "fullpath": "/hom/hou/PermissionError", "scheme": "Hom", "type": "link"}, " if this node is inside a locked asset."]}], "indent": 0, "text": [{"text": ["copyItems(self, items, channel_reference_originals = False)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"_hs_sc": true, "text": "", "value": "/hom/hou/NetworkMovableItem", "fallback_text": "hou.NetworkMovableItem", "fullpath": "/hom/hou/NetworkMovableItem", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::copyItems"}, "type": "methods_item", "id": "copyItems"}, {"body": [{"indent": 4, "type": "para", "text": ["Destroys all the items in the provided tuple of\n    ", {"_hs_sc": true, "text": "", "value": "/hom/hou/NetworkMovableItem", "fallback_text": "hou.NetworkMovableItem", "fullpath": "/hom/hou/NetworkMovableItem", "scheme": "Hom", "type": "link"}, " objects. This is significantly more efficient\n    than looping over the items and calling ", {"text": ["destroy()"], "type": "code"}, " on each one. It also\n    safely handles cases where one object may not be allowed to be deleted\n    unless another object is also deleted."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"_hs_sc": true, "text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if one or more of the provided items is\n    not a child of this node.\n    Raises ", {"_hs_sc": true, "text": "", "value": "/hom/hou/PermissionError", "fallback_text": "hou.PermissionError", "fullpath": "/hom/hou/PermissionError", "scheme": "Hom", "type": "link"}, " if this node is or is inside a locked\n    digital asset."]}], "indent": 0, "text": [{"text": ["deleteItems(self, items)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::deleteItems"}, "type": "methods_item", "id": "deleteItems"}], "container": true, "role": "item_group", "type": "methods_item_group"}], "indent": 0, "level": 2, "text": ["Adding and removing"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Return a boolean to indicate of the node is the last selected node in its\n    network."]}, {"indent": 4, "type": "para", "text": ["Each network (i.e. node containing children) stores its own list of\n    selected nodes, and the last selected node has special meaning.  For\n    example, it is the node displayed in unpinned parameter panes."]}, {"indent": 4, "type": "para", "text": ["See also ", {"_hs_sc": true, "text": "", "value": "/hom/hou/selectedNodes", "fallback_text": "hou.selectedNodes", "fullpath": "/hom/hou/selectedNodes", "scheme": "Hom", "type": "link"}, " to get a tuple of all the selected nodes\n    in all networks in Houdini.  The last node in this list also has special\n    meaning in Houdini, and corresponds to the global current node."]}], "indent": 0, "text": [{"text": ["isCurrent(self)"], "type": "code"}, "  \u2192 ", {"text": ["bool"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::isCurrent", "replaces": "/commands/opget /expressions/opflag"}, "type": "methods_item", "id": "isCurrent"}, {"body": [{"indent": 4, "type": "para", "text": ["Set or unset this node as the last selected one."]}, {"indent": 4, "type": "para", "text": ["Each network (i.e. node containing children) stores its own list of\n    selected nodes, and the last selected node has special meaning.  For\n    example, it is the node displayed in unpinned parameter panes."]}, {"indent": 4, "type": "para", "text": ["If ", {"text": ["on"], "type": "code"}, " is True, this node will become the last selected node.  If it\n    is False and this node was the last selected one, it will be unselected\n    and the second-last selected node will become the last selected node."]}, {"indent": 4, "type": "para", "text": ["If ", {"text": ["clear_all_selected"], "type": "code"}, " is true, Houdini will unselect every node in\n    this network before performing the operation."]}, {"indent": 4, "type": "para", "text": ["See also ", {"_hs_sc": true, "fragment": "#setSelected", "text": "", "value": "/hom/hou/Node#setSelected", "fallback_text": "hou.Node.setSelected", "fullpath": "/hom/hou/Node#setSelected", "scheme": "Hom", "type": "link"}, " and ", {"_hs_sc": true, "text": "", "value": "/hom/hou/selectedNodes", "fallback_text": "hou.selectedNodes", "fullpath": "/hom/hou/selectedNodes", "scheme": "Hom", "type": "link"}, "."]}], "indent": 0, "text": [{"text": ["setCurrent(self, on, clear_all_selected=False)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::setCurrent", "replaces": "/commands/opset"}, "type": "methods_item", "id": "setCurrent"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a tuple containing the children of this node that are selected.\n    Note that the last selected node has special meaning, and can also be\n    retrieved with ", {"_hs_sc": true, "fragment": "#isCurrent", "text": "", "value": "/hom/hou/Node#isCurrent", "fallback_text": "hou.Node.isCurrent", "fullpath": "/hom/hou/Node#isCurrent", "scheme": "Hom", "type": "link"}, "."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["If False, hidden nodes are not included in the result, even if they\n        are selected."]}], "indent": 4, "type": "dt", "text": [{"text": ["include_hidden"], "type": "code"}]}, {"body": [{"indent": 8, "type": "para", "text": ["If True, include in the returned tuple any hidden nodes that exist\n        solely to support nodes that are actually selected. This specifically\n        refers to VOP Parameter nodes, but may include other support nodes\n        as well."]}], "indent": 4, "type": "dt", "text": [{"text": ["include_hidden_support_nodes"], "type": "code"}]}], "container": true, "type": "dt_group"}, {"indent": 4, "type": "para", "text": ["The following example will print the names of all selected objects in\n    ", {"text": ["/obj"], "type": "code"}, ":"]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    for n in hou.node(\"/obj\").selectedChildren():\n        print n.name()\n    "]}, {"indent": 4, "type": "para", "text": ["To find the total number of selected children nodes, use\n    ", {"text": ["len(node.selectedChildren())"], "type": "code"}, "."]}], "indent": 0, "text": [{"text": ["selectedChildren(self, include_hidden=False, include_hidden_support_nodes=False)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"_hs_sc": true, "text": "", "value": "/hom/hou/Node", "fallback_text": "hou.Node", "fullpath": "/hom/hou/Node", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::selectedChildren", "replaces": "/commands/opget"}, "type": "methods_item", "id": "selectedChildren"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a tuple containing the children of this node that are selected.\n    Unlike ", {"text": ["selectedChildren"], "type": "code"}, ", this method will also return any selected\n    ", {"_hs_sc": true, "text": "", "value": "/hom/hou/NetworkBox", "fallback_text": "hou.NetworkBox", "fullpath": "/hom/hou/NetworkBox", "scheme": "Hom", "type": "link"}, ", ", {"_hs_sc": true, "text": "", "value": "/hom/hou/SubnetIndirectInput", "fallback_text": "hou.SubnetIndirectInput", "fullpath": "/hom/hou/SubnetIndirectInput", "scheme": "Hom", "type": "link"}, ",\n    ", {"_hs_sc": true, "text": "", "value": "/hom/hou/StickyNote", "fallback_text": "hou.StickyNote", "fullpath": "/hom/hou/StickyNote", "scheme": "Hom", "type": "link"}, ", and ", {"_hs_sc": true, "text": "", "value": "/hom/hou/NetworkDot", "fallback_text": "hou.NetworkDot", "fullpath": "/hom/hou/NetworkDot", "scheme": "Hom", "type": "link"}, " objects."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["If False, hidden nodes are not included in the result, even if they\n        are selected. Other network item types cannot be hidden, and so are\n        unaffected by the value of this parameter."]}], "indent": 4, "type": "dt", "text": [{"text": ["include_hidden"], "type": "code"}]}, {"body": [{"indent": 8, "type": "para", "text": ["If True, include in the returned tuple any hidden nodes that exist\n        solely to support nodes that are actually selected. This specifically\n        refers to VOP Parameter nodes, but may include other support nodes\n        as well."]}], "indent": 4, "type": "dt", "text": [{"text": ["include_hidden_support_nodes"], "type": "code"}]}], "container": true, "type": "dt_group"}, {"indent": 4, "type": "para", "text": ["The following example will print the positions of all selected items in\n    ", {"text": ["/obj"], "type": "code"}, ":"]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    for n in hou.node(\"/obj\").selectedItems():\n        print n.position()\n    "]}], "indent": 0, "text": [{"text": ["selectedItems(self, include_hidden=False, include_hidden_support_nodes=False)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"_hs_sc": true, "text": "", "value": "/hom/hou/NetworkMovableItem", "fallback_text": "hou.NetworkMovableItem", "fullpath": "/hom/hou/NetworkMovableItem", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::selectedItems"}, "type": "methods_item", "id": "selectedItems"}], "container": true, "role": "item_group", "type": "methods_item_group"}], "indent": 0, "level": 2, "text": ["Selection"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Return the ", {"_hs_sc": true, "text": "", "value": "/hom/hou/NodeType", "fallback_text": "hou.NodeType", "fullpath": "/hom/hou/NodeType", "scheme": "Hom", "type": "link"}, " object for this node."]}, {"indent": 4, "type": "para", "text": ["For example, all camera node instances share the same node type."]}], "indent": 0, "text": [{"text": ["type(self)"], "type": "code"}, "  \u2192 ", {"_hs_sc": true, "text": "", "value": "/hom/hou/NodeType", "fallback_text": "hou.NodeType", "fullpath": "/hom/hou/NodeType", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::type", "replaces": "/commands/optype /expressions/optype"}, "type": "methods_item", "id": "type"}, {"body": [{"indent": 4, "type": "para", "text": ["Changes the node to a new type (within the same context). ", {"text": ["new_node_type"], "type": "code"}, "\n    is the internal string name of the type you want to change to."]}, {"indent": 4, "type": "para", "text": [{"text": ["Keep_name"], "type": "code"}, ", ", {"text": ["keep_parms"], "type": "code"}, ", and ", {"text": ["keep_network_contents"], "type": "code"}, " indicate that the\n    node should keep the same name, parameter values, and contents,\n    respectively, after its type has changed.  ", {"text": ["force_change_on_node_type_match"], "type": "code"}, "\n    indicates whether to perform the change even when is already of the\n    specified type."]}], "indent": 0, "text": [{"text": ["changeNodeType(self, new_node_type, keep_name=True, keep_parms=True, keep_network_contents=True, force_change_on_node_type_match=False)"], "type": "code"}, "  \u2192 ", {"_hs_sc": true, "text": "", "value": "/hom/hou/Node", "fallback_text": "hou.Node", "fullpath": "/hom/hou/Node", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::changeNodeType", "replaces": "/commands/opchangetype"}, "type": "methods_item", "id": "changeNodeType"}, {"body": [{"indent": 4, "type": "para", "text": ["Return the ", {"_hs_sc": true, "text": "", "value": "/hom/hou/NodeTypeCategory", "fallback_text": "hou.NodeTypeCategory", "fullpath": "/hom/hou/NodeTypeCategory", "scheme": "Hom", "type": "link"}, " corresponding to the children of\n    this node.  For example, if this node is a geometry object, the children\n    are SOPs.  If it is an object subnet, the children are objects."]}], "indent": 0, "text": [{"text": ["childTypeCategory(self)"], "type": "code"}, "  \u2192 ", {"_hs_sc": true, "text": "", "value": "/hom/hou/NodeTypeCategory", "fallback_text": "hou.NodeTypeCategory", "fullpath": "/hom/hou/NodeTypeCategory", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::childTypeCategory"}, "type": "methods_item", "id": "childTypeCategory"}], "container": true, "role": "item_group", "type": "methods_item_group"}], "indent": 0, "level": 2, "text": ["Types"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Return the parameter at the given path, or ", {"text": ["None"], "type": "code"}, " if the parameter\n    doesn\u2019t exist."]}], "indent": 0, "text": [{"text": ["parm(self, parm_path)"], "type": "code"}, "  \u2192 ", {"_hs_sc": true, "text": "", "value": "/hom/hou/Parm", "fallback_text": "hou.Parm", "fullpath": "/hom/hou/Parm", "scheme": "Hom", "type": "link"}, " or ", {"text": ["None"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::parm", "replaces": "/expressions/chexist"}, "type": "methods_item", "id": "parm"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a tuple of parameters matching the pattern."]}, {"indent": 4, "type": "para", "text": ["The pattern may contain multiple pieces, separated by spaces.  An asterisk\n    (", {"text": ["*"], "type": "code"}, ") in a pattern piece will match any character.  By default, Houdini\n    will add the parameters from each pattern piece to those already matched.\n    However, if the pattern piece begins with a caret (", {"text": ["^"], "type": "code"}, "), Houdini will\n    remove the matches for that piece from the result."]}, {"indent": 4, "type": "para", "text": ["By default the pattern match is case-sensitive.  Set ", {"text": ["ignore_case"], "type": "code"}, " to\n    True for case-insensitive pattern matching.  Note that case insensitivity\n    only applies when matching node and parameter names.  It does not apply\n    when matching group, network box or bundle names."]}, {"indent": 4, "type": "para", "text": ["This method returns an empty tuple if you pass in an empty pattern."]}], "indent": 0, "text": [{"text": ["globParms(self, pattern, ignore_case=False)"], "type": "code"}, "  \u2192 tuple of ", {"_hs_sc": true, "text": "", "value": "/hom/hou/Parm", "fallback_text": "hou.Parm", "fullpath": "/hom/hou/Parm", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::globParms", "replaces": "/commands/chls"}, "type": "methods_item", "id": "globParms"}, {"body": [{"indent": 4, "type": "para", "text": ["Evaluates the specified parameter and returns the result."]}], "indent": 0, "text": [{"text": ["evalParm(self, parm_path)"], "type": "code"}, "  \u2192 ", {"text": ["int"], "type": "code"}, ", ", {"text": ["float"], "type": "code"}, ", or ", {"text": ["str"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::evalParm", "replaces": "/expressions/ch /expressions/chs"}, "type": "methods_item", "id": "evalParm"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a list of the parameters on this node."]}], "indent": 0, "text": [{"text": ["parms(self)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"_hs_sc": true, "text": "", "value": "/hom/hou/Parm", "fallback_text": "hou.Parm", "fullpath": "/hom/hou/Parm", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::parms", "replaces": "/commands/opparm"}, "type": "methods_item", "id": "parms"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a list of the parameters that reference this node."]}], "indent": 0, "text": [{"text": ["parmsReferencingThis(self)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"_hs_sc": true, "text": "", "value": "/hom/hou/Parm", "fallback_text": "hou.Parm", "fullpath": "/hom/hou/Parm", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::parmsReferencingThis"}, "type": "methods_item", "id": "parmsReferencingThis"}, {"body": [{"indent": 4, "type": "para", "text": ["Recursively return a sequence of all the parameters on all of the nodes\n    contained in this node including this node."]}, {"indent": 4, "type": "para", "text": ["This method is a generator and does not return a tuple."]}, {"indent": 4, "type": "para", "text": ["Here is an example of printing out the parameter paths for all nodes under /obj:"]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    root_node = hou.node(\"/obj\")\n    for parm in root_node.allParms():\n        print parm.path()\n    "]}], "indent": 0, "text": [{"text": ["allParms(self)"], "type": "code"}, "  \u2192 generator of ", {"_hs_sc": true, "text": "", "value": "/hom/hou/Parm", "fallback_text": "hou.Parm", "fullpath": "/hom/hou/Parm", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::allParms"}, "type": "methods_item", "id": "allParms"}, {"body": [{"indent": 4, "type": "para", "text": ["Given a dictionary mapping parm names to values, set each of the\n    corresponding parms on this node to the given value in the dictionary."]}, {"indent": 4, "type": "para", "text": ["The following example sets the ", {"text": ["tx"], "type": "code"}, " and ", {"text": ["sy"], "type": "code"}, " parameters at once:"]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    >>> node = hou.node(\"/obj\").createNode(\"geo\")\n    >>> node.setParms({\"tx\": 1, \"sy\": 3})\n    "]}, {"indent": 4, "type": "para", "text": ["Raises ", {"_hs_sc": true, "text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if any of the parameter names are not\n    valid."]}, {"indent": 4, "type": "para", "text": ["See also the ", {"_hs_sc": true, "fragment": "#setParmExpressions", "text": ["setParmExpressions"], "value": "/hom/hou/Node#setParmExpressions", "fullpath": "/hom/hou/Node#setParmExpressions", "scheme": "Hom", "type": "link"}, " method."]}], "indent": 0, "text": [{"text": ["setParms(self, parm_dict)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::setParms"}, "type": "methods_item", "id": "setParms"}, {"body": [{"indent": 4, "type": "para", "text": ["Given a dictionary mapping parm names to expression strings, set each of\n    the corresponding parms on this node to the given expression string in\n    the dictionary."]}, {"indent": 4, "type": "para", "text": ["See ", {"_hs_sc": true, "fragment": "#setExpression", "text": "", "value": "/hom/hou/Parm#setExpression", "fallback_text": "hou.Parm.setExpression", "fullpath": "/hom/hou/Parm#setExpression", "scheme": "Hom", "type": "link"}, " for a description of the ", {"text": ["language"], "type": "code"}, " and\n    ", {"text": ["replace_expressions"], "type": "code"}, " parms."]}, {"indent": 4, "type": "para", "text": ["The following example expressions set the ", {"text": ["tx"], "type": "code"}, " and ", {"text": ["sy"], "type": "code"}, " parameters at once:"]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    >>> node = hou.node(\"/obj\").createNode(\"geo\")\n    >>> node.setParmExpressions({\"tx\": 'ch(\"ty\")', \"sy\": \"sin($F)\"})\n    "]}, {"indent": 4, "type": "para", "text": ["Raises ", {"_hs_sc": true, "text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if any of the parameter names are not\n    valid."]}, {"indent": 4, "type": "para", "text": ["See also the ", {"_hs_sc": true, "fragment": "#setParms", "text": ["setParms"], "value": "/hom/hou/Node#setParms", "fullpath": "/hom/hou/Node#setParms", "scheme": "Hom", "type": "link"}, " method."]}], "indent": 0, "text": [{"text": ["setParmExpressions(self, parm_dict, language=None, replace_expressions=True)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::setParmExpressions"}, "type": "methods_item", "id": "setParmExpressions"}, {"body": [{"indent": 4, "type": "para", "text": ["Return the parm tuple at the given path, or ", {"text": ["None"], "type": "code"}, " if it doesn\u2019t exist."]}, {"indent": 4, "type": "para", "text": ["This method is similar to ", {"text": ["parm()"], "type": "code"}, ", except it returns a\n    ", {"_hs_sc": true, "text": "", "value": "/hom/hou/ParmTuple", "fallback_text": "hou.ParmTuple", "fullpath": "/hom/hou/ParmTuple", "scheme": "Hom", "type": "link"}, " instead of a ", {"_hs_sc": true, "text": "", "value": "/hom/hou/Parm", "fallback_text": "hou.Parm", "fullpath": "/hom/hou/Parm", "scheme": "Hom", "type": "link"}, "."]}], "indent": 0, "text": [{"text": ["parmTuple(self, parm_path)"], "type": "code"}, "  \u2192 ", {"_hs_sc": true, "text": "", "value": "/hom/hou/ParmTuple", "fallback_text": "hou.ParmTuple", "fullpath": "/hom/hou/ParmTuple", "scheme": "Hom", "type": "link"}, " or ", {"text": ["None"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::parmTuple"}, "type": "methods_item", "id": "parmTuple"}, {"body": [{"indent": 4, "type": "para", "text": ["Evaluates the specified parameter tuple and returns the result."]}], "indent": 0, "text": [{"text": ["evalParmTuple(self, parm_path)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"text": ["int"], "type": "code"}, ", ", {"text": ["float"], "type": "code"}, ", or ", {"text": ["str"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::evalParmTuple"}, "type": "methods_item", "id": "evalParmTuple"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a list of all parameter tuples on this node."]}, {"indent": 4, "type": "para", "text": ["This method is similar to ", {"text": ["parms()"], "type": "code"}, ", except it returns a list of\n    ", {"_hs_sc": true, "text": "", "value": "/hom/hou/ParmTuple", "fallback_text": "hou.ParmTuple", "fullpath": "/hom/hou/ParmTuple", "scheme": "Hom", "type": "link"}, " instead of ", {"_hs_sc": true, "text": "", "value": "/hom/hou/Parm", "fallback_text": "hou.Parm", "fullpath": "/hom/hou/Parm", "scheme": "Hom", "type": "link"}, "."]}], "indent": 0, "text": [{"text": ["parmTuples(self)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"_hs_sc": true, "text": "", "value": "/hom/hou/ParmTuple", "fallback_text": "hou.ParmTuple", "fullpath": "/hom/hou/ParmTuple", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::parmTuples"}, "type": "methods_item", "id": "parmTuples"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a list of parameters in a folder on this node.  Returns all\n    parameters in the folder and its subfolders (if any)."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["A sequence of folder name strings.  For example, to get a list of the\n        parameters in the Shading folder of the Render folder, use\n        ", {"text": ["(\"Render\", \"Shading\")"], "type": "code"}, ".  Note that by folder name, we mean the label\n        used in the parameter dialog, not the internal parameter name."]}, {"indent": 8, "type": "para", "text": ["If this sequence is empty, the method returns all parameters on the\n        node, the same as if you called ", {"text": ["parms()"], "type": "code"}, "."]}], "indent": 4, "type": "dt", "text": ["folder_names"]}], "container": true, "type": "dt_group"}, {"indent": 4, "type": "para", "text": ["Raises ", {"_hs_sc": true, "text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if the folder specified by ", {"text": ["folder_names"], "type": "code"}, "\n    does not exist."]}, {"indent": 4, "type": "para", "text": ["For example, suppose a node had a Render folder that contained a Shading\n    subfolder.  Then this line of code would return the parameters in the\n    Render folder:"]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    # Note the trailing comma after \"Render\" to tell Python that \"Render\" is\n    # contained in a tuple/sequence as opposed to just a single string with\n    # parentheses around it.\n    >>> node.parmsInFolder((\"Render\", ))\n    "]}, {"indent": 4, "type": "para", "text": ["And this line of code would return the parameters in the Shading subfolder."]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    >>> node.parmsInFolder((\"Render\", \"Shading\"))\n    "]}, {"indent": 4, "type": "para", "text": ["See also ", {"_hs_sc": true, "fragment": "#containingFolders", "text": "", "value": "/hom/hou/Parm#containingFolders", "fallback_text": "hou.Parm.containingFolders", "fullpath": "/hom/hou/Parm#containingFolders", "scheme": "Hom", "type": "link"}, "\n    and ", {"_hs_sc": true, "fragment": "#containingFolderSetParmTuples", "text": "", "value": "/hom/hou/Parm#containingFolderSetParmTuples", "fallback_text": "hou.Parm.containingFolderSetParmTuples", "fullpath": "/hom/hou/Parm#containingFolderSetParmTuples", "scheme": "Hom", "type": "link"}]}], "indent": 0, "text": [{"text": ["parmsInFolder(self, folder_names)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"_hs_sc": true, "text": "", "value": "/hom/hou/Parm", "fallback_text": "hou.Parm", "fullpath": "/hom/hou/Parm", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::parmsInFolder"}, "type": "methods_item", "id": "parmsInFolder"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a list of the parameter tuples in a folder on this node.\n    This method is similar to ", {"text": ["parmsInFolder()"], "type": "code"}, ", except it returns a list of\n    ", {"_hs_sc": true, "text": "", "value": "/hom/hou/ParmTuple", "fallback_text": "hou.ParmTuple", "fullpath": "/hom/hou/ParmTuple", "scheme": "Hom", "type": "link"}, " instead of ", {"_hs_sc": true, "text": "", "value": "/hom/hou/Parm", "fallback_text": "hou.Parm", "fullpath": "/hom/hou/Parm", "scheme": "Hom", "type": "link"}, ". See ", {"text": ["parmsInFolder()"], "type": "code"}, "\n    above for information about the arguments."]}, {"indent": 4, "type": "para", "text": ["See also ", {"_hs_sc": true, "fragment": "#containingFolders", "text": "", "value": "/hom/hou/Parm#containingFolders", "fallback_text": "hou.Parm.containingFolders", "fullpath": "/hom/hou/Parm#containingFolders", "scheme": "Hom", "type": "link"}, "\n    and ", {"_hs_sc": true, "fragment": "#containingFolderSetParmTuples", "text": "", "value": "/hom/hou/Parm#containingFolderSetParmTuples", "fallback_text": "hou.Parm.containingFolderSetParmTuples", "fullpath": "/hom/hou/Parm#containingFolderSetParmTuples", "scheme": "Hom", "type": "link"}]}], "indent": 0, "text": [{"text": ["parmTuplesInFolder(self, folder_names)"], "type": "code"}, "  \u2192 tuple of ", {"_hs_sc": true, "text": "", "value": "/hom/hou/ParmTuple", "fallback_text": "hou.ParmTuple", "fullpath": "/hom/hou/ParmTuple", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::parmTuplesInFolder"}, "type": "methods_item", "id": "parmTuplesInFolder"}, {"body": [{"indent": 4, "type": "para", "text": ["Return the node\u2019s default expression language."]}, {"indent": 4, "type": "para", "text": ["When you enter an expression in a parameter that does not already contain\n    an expression, the node\u2019s expression language is used to determine how\n    that expression should be evaluated.  You can change a node\u2019s expression\n    language in the parameter dialog in the GUI."]}, {"indent": 4, "type": "para", "text": ["Changing the node\u2019s expression language will not change the language in\n    parameters already containing expressions (i.e. parameters with keyframes)."]}, {"indent": 4, "type": "para", "text": ["Note that if a parameter already contains an expression and you change that\n    expression in the GUI, the expression language will not change, regardless\n    of the value of the node\u2019s expression language. To change the language of an\n    existing expression in a parameter from Python, use\n    ", {"_hs_sc": true, "fragment": "#setExpression", "text": "", "value": "/hom/hou/Parm#setExpression", "fallback_text": "hou.Parm.setExpression", "fullpath": "/hom/hou/Parm#setExpression", "scheme": "Hom", "type": "link"}, ", as in\n    ", {"text": ["parm.setExpression(parm.expression(), language)"], "type": "code"}, "."]}], "indent": 0, "text": [{"text": ["expressionLanguage(self)"], "type": "code"}, "  \u2192 ", {"_hs_sc": true, "text": "", "value": "/hom/hou/exprLanguage", "fallback_text": "hou.exprLanguage", "fullpath": "/hom/hou/exprLanguage", "scheme": "Hom", "type": "link"}, " enum value"], "role": "item", "attrs": {"cppname": "HOM_Node::expressionLanguage"}, "type": "methods_item", "id": "expressionLanguage"}, {"body": [{"indent": 4, "type": "para", "text": ["Set the node\u2019s default expression language.\n    See ", {"text": ["expressionLanguage()"], "type": "code"}, " for more information."]}], "indent": 0, "text": [{"text": ["setExpressionLanguage(self, language)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::setExpressionLanguage"}, "type": "methods_item", "id": "setExpressionLanguage"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a dictionary of parameter aliases on the node\u2019s parameters.  The\n    keys in the dictionary are the parameters that have aliases and the values\n    are the alias names."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["Return the parameter aliases for this node ", {"text": ["and its children"], "type": "em"}, "."]}], "indent": 4, "type": "dt", "text": ["recurse"]}], "container": true, "type": "dt_group"}], "indent": 0, "text": [{"text": ["parmAliases(self, recurse=False)"], "type": "code"}, "  \u2192 dict of ", {"_hs_sc": true, "text": "", "value": "/hom/hou/Parm", "fallback_text": "hou.Parm", "fullpath": "/hom/hou/Parm", "scheme": "Hom", "type": "link"}, " to ", {"text": ["str"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::parmAliases", "replaces": "/commands/chalias"}, "type": "methods_item", "id": "parmAliases"}, {"body": [{"indent": 4, "type": "para", "text": ["Removes all alias names from parameters on the node."]}], "indent": 0, "text": [{"text": ["clearParmAliases(self)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::clearParmAliases", "replaces": "/commands/chalias"}, "type": "methods_item", "id": "clearParmAliases"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a list of the spare (user-defined) parameters on this node."]}], "indent": 0, "text": [{"text": ["spareParms(self)"], "type": "code"}, "  \u2192 tuple of ", {"_hs_sc": true, "text": "", "value": "/hom/hou/Parm", "fallback_text": "hou.Parm", "fullpath": "/hom/hou/Parm", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::spareParms", "replaces": "/commands/opspare"}, "type": "methods_item", "id": "spareParms"}, {"body": [{"indent": 4, "type": "para", "text": ["Return the group of parm templates corresponding to the current parameter\n    layout for this node."]}, {"indent": 4, "type": "para", "text": ["You can edit the parameter layout for this node (add or remove spare\n    parameters, reorder or hide built-in parameters, etc.) by getting the\n    current parameter group, modifying it, and calling\n    ", {"_hs_sc": true, "fragment": "#setParmTemplateGroup", "text": "", "value": "/hom/hou/Node#setParmTemplateGroup", "fallback_text": "hou.Node.setParmTemplateGroup", "fullpath": "/hom/hou/Node#setParmTemplateGroup", "scheme": "Hom", "type": "link"}, " with it."]}, {"indent": 4, "type": "para", "text": ["The following example creates a geometry object, adds a ", {"text": ["My Parms"], "type": "code"}, " folder\n    to it, and adds a ", {"text": ["My Parm"], "type": "code"}, " float parameter to it in that folder.  The\n    parameters are added only to the geometry object created; other geometry\n    objects are unaffected."]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    >>> node = hou.node(\"/obj\").createNode(\"geo\")\n    >>> group = node.parmTemplateGroup()\n    >>> folder = hou.FolderParmTemplate(\"folder\", \"My Parms\")\n    >>> folder.addParmTemplate(hou.FloatParmTemplate(\"myparm\", \"My Parm\", 1))\n    >>> group.append(folder)\n    >>> node.setParmTemplateGroup(group)\n    "]}, {"indent": 4, "type": "para", "text": ["See ", {"_hs_sc": true, "text": "", "value": "/hom/hou/ParmTemplateGroup", "fallback_text": "hou.ParmTemplateGroup", "fullpath": "/hom/hou/ParmTemplateGroup", "scheme": "Hom", "type": "link"}, " and the\n    ", {"_hs_sc": true, "fragment": "#setParmTemplateGroup", "text": ["setParmTemplateGroup"], "value": "/hom/hou/Node#setParmTemplateGroup", "fullpath": "/hom/hou/Node#setParmTemplateGroup", "scheme": "Hom", "type": "link"}, " method for more\n    information and examples."]}], "indent": 0, "text": [{"text": ["parmTemplateGroup(self)"], "type": "code"}, "  \u2192 ", {"_hs_sc": true, "text": "", "value": "/hom/hou/ParmTemplateGroup", "fallback_text": "hou.ParmTemplateGroup", "fullpath": "/hom/hou/ParmTemplateGroup", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_HDADefinition::parmTemplateGroup", "replaces": "/commands/opspare"}, "type": "methods_item", "id": "parmTemplateGroup"}, {"body": [{"indent": 4, "type": "para", "text": ["Change the spare parameters for this node."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["A ", {"_hs_sc": true, "text": "", "value": "/hom/hou/ParmTemplateGroup", "fallback_text": "hou.ParmTemplateGroup", "fullpath": "/hom/hou/ParmTemplateGroup", "scheme": "Hom", "type": "link"}, " object containing the new parameter\n        layout."]}], "indent": 4, "type": "dt", "text": [{"text": ["parm_template_group"], "type": "code"}]}, {"body": [{"indent": 8, "type": "para", "text": ["If ", {"text": ["True"], "type": "code"}, ", parameters in the group with the same parm tuple names will\n        be automatically renamed.  If ", {"text": ["False"], "type": "code"}, " and there are parms with the same\n        name, this method raises ", {"_hs_sc": true, "text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, "."]}], "indent": 4, "type": "dt", "text": [{"text": ["rename_conflicting_parms"], "type": "code"}]}], "container": true, "type": "dt_group"}, {"indent": 4, "type": "para", "text": ["Note that each node type has a set of parameters which must exist and\n    must be of certain types.  If your parm template group does not contain\n    the required parameters for the node type the will be added at the\n    bottom and will be made invisible.  Similarly, if your parm template\n    group attempts to modify the type, range, label, or other property of\n    a required parameter, all changes to that parameter other than visibility\n    settings will be ignored."]}, {"indent": 4, "type": "para", "text": ["This method is preferred over the other parameter-related methods in this\n    class (addSpareParmTuple, removeSpareParmTuple, replaceSpareParmTuple,\n    addSpareParmFolder, removeSpareParmFolder) because it lets you more easily\n    make manipulate parameters."]}, {"indent": 4, "type": "para", "text": ["See ", {"_hs_sc": true, "fragment": "#setParmTemplateGroup", "text": "", "value": "/hom/hou/HDADefinition#setParmTemplateGroup", "fallback_text": "hou.HDADefinition.setParmTemplateGroup", "fullpath": "/hom/hou/HDADefinition#setParmTemplateGroup", "scheme": "Hom", "type": "link"}, " to change the parameter\n    interface of a digital asset."]}], "indent": 0, "text": [{"text": ["setParmTemplateGroup(self, parm_template_group, rename_conflicting_parms=False)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_HDADefinition::setParmTemplateGroup", "replaces": "/commands/opspare"}, "type": "methods_item", "id": "setParmTemplateGroup"}, {"body": [{"indent": 4, "type": "para", "text": ["Add a spare parameter tuple to the end of the parameters on the node.  If\n    ", {"text": ["in_folder"], "type": "code"}, " is not an empty sequence, this method adds the parameters to\n    the end of the parameters in a particular folder."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["A ", {"_hs_sc": true, "text": "", "value": "/hom/hou/ParmTemplate", "fallback_text": "hou.ParmTemplate", "fullpath": "/hom/hou/ParmTemplate", "scheme": "Hom", "type": "link"}, " subclass instance that specifies the type\n        of parameter tuple, the default value, range, etc."]}], "indent": 4, "type": "dt", "text": ["parm_template"]}, {"body": [{"indent": 8, "type": "para", "text": ["A sequence of folder names specifying which folder will hold the\n        parameter.  If this parameter is an empty sequence (e.g. ", {"text": ["()"], "type": "code"}, "), Houdini\n        will not put the parameter inside a folder.  If it is, for example,\n        ", {"text": ["(\"Misc\", \"Controls\")"], "type": "code"}, ", Houdini puts it inside the \"Controls\" folder\n        that\u2019s inside the \"Misc\" folder.  If it is, for example, ", {"text": ["(\"Misc\",)"], "type": "code"}, ",\n        Houdini puts it inside the \"Misc\" folder."]}], "indent": 4, "type": "dt", "text": ["in_folder"]}, {"body": [{"indent": 8, "type": "para", "text": ["If True, and the folder location specified by ", {"text": ["in_folder"], "type": "code"}, " does not\n        exist, this method creates the missing containing folders."]}], "indent": 4, "type": "dt", "text": ["create_missing_folders"]}], "container": true, "type": "dt_group"}, {"indent": 4, "type": "para", "text": ["Note that this method can add a single folder by passing a\n    ", {"_hs_sc": true, "text": "", "value": "/hom/hou/FolderParmTemplate", "fallback_text": "hou.FolderParmTemplate", "fullpath": "/hom/hou/FolderParmTemplate", "scheme": "Hom", "type": "link"}, " for ", {"text": ["parm_template"], "type": "code"}, "."]}, {"indent": 4, "type": "para", "text": ["See also the ", {"text": ["removeSpareParmTuple()"], "type": "code"}, " and ", {"text": ["addSpareParmFolder()"], "type": "code"}, " methods."]}, {"indent": 4, "type": "para", "text": ["This method is deprecated in favor of ", {"text": ["setParmTemplateGroup"], "type": "code"}, "."]}], "indent": 0, "text": [{"text": ["addSpareParmTuple(self, parm_template, in_folder=(), create_missing_folders=False)"], "type": "code"}, "  \u2192 ", {"_hs_sc": true, "text": "", "value": "/hom/hou/ParmTuple", "fallback_text": "hou.ParmTuple", "fullpath": "/hom/hou/ParmTuple", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::addSpareParmTuple", "replaces": "/commands/opspare"}, "type": "methods_item", "id": "addSpareParmTuple"}, {"body": [{"indent": 4, "type": "para", "text": ["Removes the specified spare parameter tuple."]}, {"indent": 4, "type": "para", "text": ["See also ", {"text": ["addSpareParmTuple()"], "type": "code"}, "."]}, {"indent": 4, "type": "para", "text": ["This method is deprecated in favor of ", {"text": ["setParmTemplateGroup"], "type": "code"}, "."]}], "indent": 0, "text": [{"text": ["removeSpareParmTuple(self, parm_tuple)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::removeSpareParmTuple"}, "type": "methods_item", "id": "removeSpareParmTuple"}, {"body": [{"indent": 4, "type": "para", "text": ["Adds a control parameter folder as the front-most folder at the top-level.\n    This is used to increase visibility of customized control parameters. If a \n    folder of the same name already exists, no new folder will be created.\n    If folder_name is None, it will be set as 'Controls'. If parm_name is None,\n    it will be set as 'folder'."]}, {"indent": 4, "type": "para", "text": ["If there are no current folders present, the existing parameters will be\n    grouped together and stored into a new folder named 'Parameters' and placed\n    after the new control parameter folder."]}], "indent": 0, "text": [{"text": ["addControlParmFolder(self, folder_name=None, parm_name=None)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::addControlParmFolder"}, "type": "methods_item", "id": "addControlParmFolder"}, {"body": [{"indent": 4, "type": "para", "text": ["Adds a folder to the spare parameters."]}, {"indent": 4, "type": "para", "text": ["Note that all the folders in a set correspond to one parameter.  If this\n    is the first folder to go in the set, parm_name will be used as the\n    parameter name.  Otherwise, parm_name will be ignored and the parameter\n    name of the first folder in the set is used."]}, {"indent": 4, "type": "para", "text": ["If this is the first folder in the set and parm_name is None, it will\n    default to 'sparefolder0'.  If parm_name is already in use, a unique name\n    will be automatically generated."]}, {"indent": 4, "type": "para", "text": ["If ", {"text": ["create_missing_folders"], "type": "code"}, " is True, this method will create the folders in\n    in_folder that don\u2019t exist. So, this method can be used to add spare folders\n    and a spare parameter at the same time."]}, {"indent": 4, "type": "para", "text": ["Note that you can add folders by passing a ", {"_hs_sc": true, "text": "", "value": "/hom/hou/FolderParmTemplate", "fallback_text": "hou.FolderParmTemplate", "fullpath": "/hom/hou/FolderParmTemplate", "scheme": "Hom", "type": "link"}, "\n    to the ", {"text": ["addSpareParmTuple"], "type": "code"}, " method, so this method is deprecated.  Note\n    also that ", {"text": ["addSpareParmTuple"], "type": "code"}, " is deprecated in favor of\n    ", {"text": ["setParmTemplateGroup"], "type": "code"}, "."]}, {"indent": 4, "type": "para", "text": ["See also the ", {"text": ["removeSpareParmFolder"], "type": "code"}, " and ", {"text": ["addSpareParmTuple"], "type": "code"}, " methods."]}, {"indent": 4, "type": "para", "text": ["This method is deprecated in favor of ", {"text": ["setParmTemplateGroup"], "type": "code"}, "."]}], "indent": 0, "text": [{"text": ["addSpareParmFolder(self, folder_name, in_folder=(), parm_name=None, create_missing_folders=False)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::addSpareParmFolder"}, "type": "methods_item", "id": "addSpareParmFolder"}, {"body": [{"indent": 4, "type": "para", "text": ["Removes an empty folder from the spare parameters."]}, {"indent": 4, "type": "para", "text": [{"text": ["folder"], "type": "code"}, " is a sequence of folder names.  So, to remove\n    the Output folder, use ", {"text": ["(\"Output\",)"], "type": "code"}, " instead of ", {"text": ["\"Output\""], "type": "code"}, "."]}, {"indent": 4, "type": "para", "text": ["See also ", {"text": ["addSpareParmFolder()"], "type": "code"}, ", ", {"_hs_sc": true, "fragment": "#remove", "text": "", "value": "/hom/hou/ParmTemplateGroup#remove", "fallback_text": "hou.ParmTemplateGroup.remove", "fullpath": "/hom/hou/ParmTemplateGroup#remove", "scheme": "Hom", "type": "link"}, ", and\n    ", {"_hs_sc": true, "fragment": "#findFolder", "text": "", "value": "/hom/hou/ParmTemplateGroup#findFolder", "fallback_text": "hou.ParmTemplateGroup.findFolder", "fullpath": "/hom/hou/ParmTemplateGroup#findFolder", "scheme": "Hom", "type": "link"}, "."]}], "indent": 0, "text": [{"text": ["removeSpareParmFolder(self, folder)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::removeSpareParmFolder"}, "type": "methods_item", "id": "removeSpareParmFolder"}, {"body": [{"indent": 4, "type": "para", "text": ["Replace an existing spare parameter tuple with a new one.  The old\n    parameter tuple is removed and the new one is added in its place."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["The name of the spare parameter tuple to replace.  Raises\n        ", {"_hs_sc": true, "text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if no parameter tuple exists with this name,\n        or if it is the name of a non-spare parameter."]}], "indent": 4, "type": "dt", "text": ["parm_tuple_name"]}, {"body": [{"indent": 8, "type": "para", "text": ["A ", {"_hs_sc": true, "text": "", "value": "/hom/hou/ParmTemplate", "fallback_text": "hou.ParmTemplate", "fullpath": "/hom/hou/ParmTemplate", "scheme": "Hom", "type": "link"}, " describing the new parameter tuple."]}], "indent": 4, "type": "dt", "text": ["parm_template"]}], "container": true, "type": "dt_group"}, {"indent": 4, "type": "para", "text": ["The new parameter tuple may or may not have the same name as the old one.\n    By providing a parameter tuple with the same name, you can modify an\n    existing spare parameter tuple."]}, {"indent": 4, "type": "para", "text": ["Note that you cannot replace non-spare parameter tuples.  However, you can\n    change the visibility of non-spare parameters using\n    ", {"_hs_sc": true, "fragment": "#hide", "text": "", "value": "/hom/hou/ParmTuple#hide", "fallback_text": "hou.ParmTuple.hide", "fullpath": "/hom/hou/ParmTuple#hide", "scheme": "Hom", "type": "link"}, "."]}, {"indent": 4, "type": "para", "text": ["To change a parameter for all instances of digital asset, use\n    ", {"_hs_sc": true, "fragment": "#replaceParmTuple", "text": "", "value": "/hom/hou/HDADefinition#replaceParmTuple", "fallback_text": "hou.HDADefinition.replaceParmTuple", "fullpath": "/hom/hou/HDADefinition#replaceParmTuple", "scheme": "Hom", "type": "link"}, "."]}, {"indent": 4, "type": "para", "text": ["This method is deprecated in favor of ", {"text": ["setParmTemplateGroup"], "type": "code"}, "."]}], "indent": 0, "text": [{"text": ["replaceSpareParmTuple(self, parm_tuple_name, parm_template)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::replaceSpareParmTuple"}, "type": "methods_item", "id": "replaceSpareParmTuple"}], "container": true, "role": "item_group", "type": "methods_item_group"}], "indent": 0, "level": 2, "text": ["Parameters"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Return a tuple of the nodes connected to this node\u2019s inputs. If an input\n    is connected to a ", {"_hs_sc": true, "text": "", "value": "/hom/hou/SubnetIndirectInput", "fallback_text": "hou.SubnetIndirectInput", "fullpath": "/hom/hou/SubnetIndirectInput", "scheme": "Hom", "type": "link"}, ", the node connected to the\n    corresponding input on the parent subnet is returned. In other words the\n    presence of the indirect input is hidden. This means the resulting nodes\n    may not all be siblings of the calling node."]}, {"indent": 4, "type": "para", "text": ["If a particular input is not connected (or is connected to an indirect\n    input and the corresponding subnet parent input is not connected), a\n    ", {"text": ["None"], "type": "code"}, " value is placed in the tuple at that location."]}], "indent": 0, "text": [{"text": ["inputs(self)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"_hs_sc": true, "text": "", "value": "/hom/hou/Node", "fallback_text": "hou.Node", "fullpath": "/hom/hou/Node", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::inputs", "replaces": "/commands/opgetinput /expressions/opinputs /expressions/opninputs /expressions/icl /expressions/icn /expressions/icr /expressions/ics"}, "type": "methods_item", "id": "inputs"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a tuple of the nodes connected to this node\u2019s outputs."]}, {"indent": 4, "type": "para", "text": ["This method is a shortcut for ", {"text": ["[connection.inputNode() for connection in\n    self.outputConnections()]"], "type": "code"}, "."]}], "indent": 0, "text": [{"text": ["outputs(self)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"_hs_sc": true, "text": "", "value": "/hom/hou/Node", "fallback_text": "hou.Node", "fullpath": "/hom/hou/Node", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::outputs", "replaces": "/expressions/opoutput /commands/opdepend /expressions/opnoutputs"}, "type": "methods_item", "id": "outputs"}, {"body": [{"indent": 4, "type": "para", "text": ["Returns a tuple of ", {"_hs_sc": true, "text": "", "value": "/hom/hou/NodeConnection", "fallback_text": "hou.NodeConnection", "fullpath": "/hom/hou/NodeConnection", "scheme": "Hom", "type": "link"}, " objects for the connections\n    coming into the top of this node. The tuple will have a length equal to\n    the number of connections coming into the node.  Returns an empty tuple\n    if nothing is connected to this node."]}, {"indent": 4, "type": "para", "text": ["To get a list of the connected nodes themselves, use ", {"_hs_sc": true, "fragment": "#inputs", "text": "", "value": "/hom/hou/Node#inputs", "fallback_text": "hou.Node.inputs", "fullpath": "/hom/hou/Node#inputs", "scheme": "Hom", "type": "link"}, ".\n    To get a list of all possible connection sites (whether or not anything\n    is connected to them), use ", {"_hs_sc": true, "fragment": "#inputConnectors", "text": "", "value": "/hom/hou/Node#inputConnectors", "fallback_text": "hou.Node.inputConnectors", "fullpath": "/hom/hou/Node#inputConnectors", "scheme": "Hom", "type": "link"}, "."]}, {"lang": "pycon", "indent": 4, "type": "pre", "text": ["\n    >>> cookie = hou.node(\"/obj\").createNode(\"geo\").createNode(\"cookie\")\n    >>> cookie.setInput(1, cookie.parent().createNode(\"box\"))\n    >>> cookie.inputConnections()\n    (<hou.NodeConnection from grid1 output 0 to cookie input 1>,)\n    >>> cookie.inputConnectors()\n    ((), (<hou.NodeConnection from grid1 output 0 to cookie input 1>,))\n    "]}, {"indent": 4, "type": "para", "text": ["See also ", {"_hs_sc": true, "fragment": "#inputConnectors", "text": "", "value": "/hom/hou/Node#inputConnectors", "fallback_text": "hou.Node.inputConnectors", "fullpath": "/hom/hou/Node#inputConnectors", "scheme": "Hom", "type": "link"}, "."]}], "indent": 0, "text": [{"text": ["inputConnections(self)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"_hs_sc": true, "text": "", "value": "/hom/hou/NodeConnection", "fallback_text": "hou.NodeConnection", "fullpath": "/hom/hou/NodeConnection", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::inputConnections", "replaces": "/commands/opgetinput"}, "type": "methods_item", "id": "inputConnections"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a tuple of NodeConnection objects for the connections going out of\n    the bottom of this node.  If nothing is wired into the output of this\n    node, return an empty tuple."]}, {"indent": 4, "type": "para", "text": ["To get a list of the connected nodes themselves, use\n    ", {"_hs_sc": true, "fragment": "#outputs", "text": "", "value": "/hom/hou/Node#outputs", "fallback_text": "hou.Node.outputs", "fullpath": "/hom/hou/Node#outputs", "scheme": "Hom", "type": "link"}, "."]}, {"indent": 4, "type": "para", "text": ["Note that this method is a shortcut for: ", {"text": ["reduce(lambda a, b: a+b,\n    self.outputConnectors(), ())"], "type": "code"}, ".  Since most nodes have only one output\n    connector, though, this method is usually equivalent to\n    ", {"text": ["self.outputConnectors()[0]"], "type": "code"}, "."]}, {"lang": "pycon", "indent": 4, "type": "pre", "text": ["\n    >>> box = hou.node(\"/obj\").createNode(\"geo\").createNode(\"box\")\n    >>> box.parent().createNode(\"xform\").setFirstInput(box)\n    >>> box.parent().createNode(\"subdivide\").setFirstInput(box)\n    >>> box.outputConnections()\n    (<hou.NodeConnection from box1 output 0 to xform1 output 0>, <hou.NodeConnection from box1 output 0 to subdivide1 input 0>)\n    "]}, {"indent": 4, "type": "para", "text": ["See also ", {"_hs_sc": true, "fragment": "#outputConnectors", "text": "", "value": "/hom/hou/node#outputConnectors", "fallback_text": "hou.node.outputConnectors", "fullpath": "/hom/hou/node#outputConnectors", "scheme": "Hom", "type": "link"}, "."]}], "indent": 0, "text": [{"text": ["outputConnections(self)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"_hs_sc": true, "text": "", "value": "/hom/hou/NodeConnection", "fallback_text": "hou.NodeConnection", "fullpath": "/hom/hou/NodeConnection", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::outputConnections "}, "type": "methods_item", "id": "outputConnections"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a tuple of tuples of ", {"_hs_sc": true, "text": "", "value": "/hom/hou/NodeConnection", "fallback_text": "hou.NodeConnection", "fullpath": "/hom/hou/NodeConnection", "scheme": "Hom", "type": "link"}, " objects.  The length\n    of the result tuple is equal to the maximum number of inputs that can be\n    connected to this node.  Each subtuple contains exactly one node\n    connection if something is wired into the connector; otherwise it is the\n    empty tuple."]}, {"indent": 4, "type": "para", "text": ["See also ", {"_hs_sc": true, "text": "", "value": "/hom/hou/NodeConnection", "fallback_text": "hou.NodeConnection", "fullpath": "/hom/hou/NodeConnection", "scheme": "Hom", "type": "link"}, " and ", {"_hs_sc": true, "fragment": "#inputConnections", "text": "", "value": "/hom/hou/Node#inputConnections", "fallback_text": "hou.Node.inputConnections", "fullpath": "/hom/hou/Node#inputConnections", "scheme": "Hom", "type": "link"}, "."]}], "indent": 0, "text": [{"text": ["inputConnectors(self)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"text": ["tuple"], "type": "code"}, " of ", {"_hs_sc": true, "text": "", "value": "/hom/hou/NodeConnection", "fallback_text": "hou.NodeConnection", "fullpath": "/hom/hou/NodeConnection", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::inputConnectors", "replaces": "/commands/opdepend /commands/opgetinput /expressions/opinput"}, "type": "methods_item", "id": "inputConnectors"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a a tuple of tuples of ", {"_hs_sc": true, "text": "", "value": "/hom/hou/NodeConnection", "fallback_text": "hou.NodeConnection", "fullpath": "/hom/hou/NodeConnection", "scheme": "Hom", "type": "link"}, " objects.  The length\n    of the result tuple is equal to the number of output connectors on this\n    node.  Each subtuple contains all the connections going out of that\n    connector, and is empty if nothing is wired to that connector."]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    >>> split = hou.node(\"/obj\").createNode(\"dopnet\").createNode(\"split\")\n    >>> split.parent().createNode(\"rbdsolver\").setFirstInput(split)\n    >>> split.parent().createNode(\"gravity\").setFirstInput(split, 1)\n    >>> split.parent().createNode(\"merge\").setFirstInput(split, 1)\n    >>> split.outputConnectors()\n    ((<hou.NodeConnection from split1 output 0 to rbdsolver1 input 0>,), (<hou.NodeConnection from split1 output 1 to gravity2 input 0>, <hou.NodeConnection from split1 output 1 to merge1 input 0>), (), ())\n    "]}, {"indent": 4, "type": "para", "text": ["See also ", {"_hs_sc": true, "text": "", "value": "/hom/hou/NodeConnection", "fallback_text": "hou.NodeConnection", "fullpath": "/hom/hou/NodeConnection", "scheme": "Hom", "type": "link"}, " and ", {"_hs_sc": true, "fragment": "#outputConnections", "text": "", "value": "/hom/hou/Node#outputConnections", "fallback_text": "hou.Node.outputConnections", "fullpath": "/hom/hou/Node#outputConnections", "scheme": "Hom", "type": "link"}, "."]}], "indent": 0, "text": [{"text": ["outputConnectors(self)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"text": ["tuple"], "type": "code"}, " of ", {"_hs_sc": true, "text": "", "value": "/hom/hou/NodeConnection", "fallback_text": "hou.NodeConnection", "fullpath": "/hom/hou/NodeConnection", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::outputConnectors", "replaces": "/expressions/opgetinput /expressions/opninputs /expressions/icl /expressions/icn /expressions/icr /expressions/ics /commands/opdepend"}, "type": "methods_item", "id": "outputConnectors"}, {"body": [{"indent": 4, "type": "para", "text": ["Return the hou.SubnetIndirectInput objects of a subnet."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"_hs_sc": true, "text": "", "value": "/hom/hou/InvalidNodeType", "fallback_text": "hou.InvalidNodeType", "fullpath": "/hom/hou/InvalidNodeType", "scheme": "Hom", "type": "link"}, " if this node is not a subnetwork."]}], "indent": 0, "text": [{"text": ["indirectInputs(self)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"_hs_sc": true, "text": "", "value": "/hom/hou/SubnetIndirectInput", "fallback_text": "hou.SubnetIndirectInput", "fullpath": "/hom/hou/SubnetIndirectInput", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::indirectInputs", "replaces": "/commands/opdepend"}, "type": "methods_item", "id": "indirectInputs"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a tuple of all input ancestors of this node.  If include_ref_inputs\n    is False, then reference inputs are not traversed.  If follow_subnets is\n    True, then instead of treating subnetwork nodes as a single node, we also\n    traverse its children starting with its display node."]}, {"indent": 4, "type": "para", "text": ["See also the ", {"text": ["inputs()"], "type": "code"}, " method."]}], "indent": 0, "text": [{"text": ["inputAncestors(self, include_ref_inputs=True, follow_subnets=False)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"_hs_sc": true, "text": "", "value": "/hom/hou/Node", "fallback_text": "hou.Node", "fullpath": "/hom/hou/Node", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::inputAncestors"}, "type": "methods_item", "id": "inputAncestors"}, {"body": [{"indent": 4, "type": "para", "text": ["Obtains an index of a node input that has the given name."]}, {"indent": 4, "type": "para", "text": ["For the node categories that use input names, it returns the index\n    of the input with the given name. For VOP nodes, the name may also be\n    a node parameter name that has a corresponding input."]}], "indent": 0, "text": [{"text": ["inputIndex(self, input_name)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::inputIndex"}, "type": "methods_item", "id": "inputIndex"}, {"body": [{"indent": 4, "type": "para", "text": ["Obtains an index of a node output that has the given name."]}, {"indent": 4, "type": "para", "text": ["For the node categories that use input names, it returns the index\n    of the output with the given name."]}], "indent": 0, "text": [{"text": ["outputIndex(self, output_name)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::outputIndex"}, "type": "methods_item", "id": "outputIndex"}, {"body": [{"indent": 4, "type": "para", "text": ["If ", {"text": ["item_to_become_input"], "type": "code"}, " is not None, connect the output connector of\n    another node to an input connector of this node.  Otherwise, disconnect\n    anything connected to the input connector."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["The index of this node\u2019s input connector."]}], "indent": 4, "type": "dt", "text": ["input_index"]}, {"body": [{"indent": 8, "type": "para", "text": ["If ", {"text": ["None"], "type": "code"}, " this method disconnects everything from the input connector.\n        If a ", {"_hs_sc": true, "text": "", "value": "/hom/hou/Node", "fallback_text": "hou.Node", "fullpath": "/hom/hou/Node", "scheme": "Hom", "type": "link"}, " or a ", {"_hs_sc": true, "text": "", "value": "/hom/hou/SubnetIndirectInput", "fallback_text": "hou.SubnetIndirectInput", "fullpath": "/hom/hou/SubnetIndirectInput", "scheme": "Hom", "type": "link"}, ", this method\n        connects its output to this node\u2019s input connector."]}], "indent": 4, "type": "dt", "text": ["item_to_become_input"]}, {"body": [{"indent": 8, "type": "para", "text": ["The index of the other node\u2019s output connector."]}], "indent": 4, "type": "dt", "text": ["output_index"]}], "container": true, "type": "dt_group"}, {"indent": 4, "type": "para", "text": ["Raises ", {"_hs_sc": true, "text": "", "value": "/hom/hou/InvalidInput", "fallback_text": "hou.InvalidInput", "fullpath": "/hom/hou/InvalidInput", "scheme": "Hom", "type": "link"}, " if ", {"text": ["output_index"], "type": "code"}, " is invalid.  Raises\n    ", {"_hs_sc": true, "text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if ", {"text": ["item_to_become_input"], "type": "code"}, " is not in the same\n    network as this node.  Raises ", {"_hs_sc": true, "text": "", "value": "/hom/hou/PermissionError", "fallback_text": "hou.PermissionError", "fullpath": "/hom/hou/PermissionError", "scheme": "Hom", "type": "link"}, " if the node is\n    inside a locked asset."]}], "indent": 0, "text": [{"text": ["setInput(self, input_index, item_to_become_input, output_index=0)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::setInput", "replaces": "/commands/opwire /commands/opunwire"}, "type": "methods_item", "id": "setInput"}, {"body": [{"indent": 4, "type": "para", "text": ["Connects an output on this node (specified by either an output name or\n    an output index) to the input on the item_to_become_input specified by\n    input_name."]}], "indent": 0, "text": [{"text": ["setNamedInput(self, input_name, item_to_become_input, output_name_or_index)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::setNamedInput"}, "type": "methods_item", "id": "setNamedInput"}, {"body": [{"indent": 4, "type": "para", "text": ["A shortcut for ", {"text": ["self.setInput(0, item_to_become_input)"], "type": "code"}, ".  See\n    ", {"_hs_sc": true, "fragment": "#setInput", "text": "", "value": "/hom/hou/Node#setInput", "fallback_text": "hou.Node.setInput", "fullpath": "/hom/hou/Node#setInput", "scheme": "Hom", "type": "link"}, " for more information."]}], "indent": 0, "text": [{"text": ["setFirstInput(self, item_to_become_input, output_index=0)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::setFirstInput", "replaces": "/commands/opwire"}, "type": "methods_item", "id": "setFirstInput"}, {"body": [{"indent": 4, "type": "para", "text": ["Connect the output connector from another node into the first unconnected\n    input connector or a multi-input connector of this node. If a node has\n    some ordered inputs followed by a multi-input connector, the\n    ", {"text": ["unordered_only"], "type": "code"}, " parameter can be used to force the input to connect to\n    the unordered multi-input connection instead of any of the ordered input\n    which may not be connected."]}, {"indent": 4, "type": "para", "text": ["This method is roughly equivalent to:"]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    for input_index, conectors in enumerate(self.inputConnectors()):\n        if len(connectors) == 0:\n            self.setInput(input_index, item_to_become_input, output_index)\n        raise hou.InvalidInput(\"All inputs are connected\")\n    "]}, {"indent": 4, "type": "para", "text": ["Raises ", {"_hs_sc": true, "text": "", "value": "/hom/hou/InvalidInput", "fallback_text": "hou.InvalidInput", "fullpath": "/hom/hou/InvalidInput", "scheme": "Hom", "type": "link"}, " if all inputs are connected.  See\n    ", {"_hs_sc": true, "fragment": "#setInput", "text": "", "value": "/hom/hou/Node#setInput", "fallback_text": "hou.Node.setInput", "fullpath": "/hom/hou/Node#setInput", "scheme": "Hom", "type": "link"}, " for more information."]}], "indent": 0, "text": [{"text": ["setNextInput(self, item_to_become_input, output_index=0, unordered_only=False)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::setNextInput", "replaces": "/commands/opwire"}, "type": "methods_item", "id": "setNextInput"}, {"body": [{"indent": 4, "type": "para", "text": ["Insert an input wire.  In other words, for each input connector after\n    input_index, shift the contents of that input connector to the next\n    one, and then call ", {"_hs_sc": true, "fragment": "#setInput", "text": "", "value": "/hom/hou/Node#setInput", "fallback_text": "hou.Node.setInput", "fullpath": "/hom/hou/Node#setInput", "scheme": "Hom", "type": "link"}, ".  See ", {"_hs_sc": true, "fragment": "#setInput", "text": "", "value": "/hom/hou/Node#setInput", "fallback_text": "hou.Node.setInput", "fullpath": "/hom/hou/Node#setInput", "scheme": "Hom", "type": "link"}, "\n    for the meanings of the parameters."]}], "indent": 0, "text": [{"text": ["insertInput(self, input_index, item_to_become_input, output_index=0)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::insertInput"}, "type": "methods_item", "id": "insertInput"}, {"body": [{"indent": 4, "type": "para", "text": ["Some nodes can have a small number of dedicated inputs with specific\n    meanings, followed by an arbitrary number of additional inputs, where\n    gaps are not permitted between the inputs (these are referred to as\n    unordere inputs). This is common in DOP nodes such as the\n    ", {"_hs_sc": true, "text": "", "value": "/nodes/dop/multisolver", "fullpath": "/nodes/dop/multisolver", "scheme": "Node", "type": "link"}, " DOP. This function returns the number of\n    dedicated (or ordered) inputs that occur before the unordered inputs\n    begin. This function will only return non-zero valus if the\n    ", {"_hs_sc": true, "fragment": "#hasUnorderedInputs", "text": "", "value": "/hom/hou/NodeType#hasUnorderedInputs", "fallback_text": "hou.NodeType.hasUnorderedInputs", "fullpath": "/hom/hou/NodeType#hasUnorderedInputs", "scheme": "Hom", "type": "link"}, " function for this node\u2019s\n    ", {"_hs_sc": true, "fragment": "#type", "text": "", "value": "/hom/hou/Node#type", "fallback_text": "hou.Node.type", "fullpath": "/hom/hou/Node#type", "scheme": "Hom", "type": "link"}, " object returns ", {"text": ["True"], "type": "code"}, "."]}], "indent": 0, "text": [{"text": ["numOrderedInputs(self)"], "type": "code"}, "  \u2192 ", {"text": ["int"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::numOrderedInputs"}, "type": "methods_item", "id": "numOrderedInputs"}, {"body": [{"indent": 4, "type": "para", "text": ["Create a new node and connect it to one of this node\u2019s inputs.  Return the\n    new node."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["The index of this node\u2019s input connector."]}], "indent": 4, "type": "dt", "text": ["input_index"]}, {"body": [{"indent": 8, "type": "para", "text": ["The name of the type of node to create.  See the\n        ", {"_hs_sc": true, "fragment": "#createNode", "text": ["createNode"], "value": "/hom/hou/Node#createNode", "fullpath": "/hom/hou/Node#createNode", "scheme": "Hom", "type": "link"}, " method for more information."]}], "indent": 4, "type": "dt", "text": ["node_type_name"]}, {"body": [{"indent": 8, "type": "para", "text": ["See the ", {"_hs_sc": true, "fragment": "#createNode", "text": ["createNode"], "value": "/hom/hou/Node#createNode", "fullpath": "/hom/hou/Node#createNode", "scheme": "Hom", "type": "link"}, " method for more\n        information."]}], "indent": 4, "type": "dt", "text": ["node_name"]}, {"body": [{"indent": 8, "type": "para", "text": ["See the ", {"_hs_sc": true, "fragment": "#createNode", "text": ["createNode"], "value": "/hom/hou/Node#createNode", "fullpath": "/hom/hou/Node#createNode", "scheme": "Hom", "type": "link"}, " method for more\n        information."]}], "indent": 4, "type": "dt", "text": ["run_init_scripts"]}, {"body": [{"indent": 8, "type": "para", "text": ["See the ", {"_hs_sc": true, "fragment": "#createNode", "text": ["createNode"], "value": "/hom/hou/Node#createNode", "fullpath": "/hom/hou/Node#createNode", "scheme": "Hom", "type": "link"}, " method for more\n        information."]}], "indent": 4, "type": "dt", "text": ["load_contents"]}, {"body": [{"indent": 8, "type": "para", "text": ["See the ", {"_hs_sc": true, "fragment": "#createNode", "text": ["createNode"], "value": "/hom/hou/Node#createNode", "fullpath": "/hom/hou/Node#createNode", "scheme": "Hom", "type": "link"}, " method for more\n        information."]}], "indent": 4, "type": "dt", "text": ["exact_type_name"]}], "container": true, "type": "dt_group"}, {"indent": 4, "type": "para", "text": ["See also the ", {"_hs_sc": true, "fragment": "#createOutputNode", "text": ["createOutputNode"], "value": "/hom/hou/Node#createOutputNode", "fullpath": "/hom/hou/Node#createOutputNode", "scheme": "Hom", "type": "link"}, " method."]}], "indent": 0, "text": [{"text": ["createInputNode(self, input_index, node_type_name, node_name=None, run_init_scripts=True, load_contents=True, bool exact_type_name=False)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::createInputNode"}, "type": "methods_item", "id": "createInputNode"}, {"body": [{"indent": 4, "type": "para", "text": ["Create a new node and connect its first input to this node\u2019s (first) output.\n    Return the new node."]}, {"indent": 4, "type": "para", "text": ["See the ", {"_hs_sc": true, "fragment": "#createNode", "text": ["createNode"], "value": "/hom/hou/Node#createNode", "fullpath": "/hom/hou/Node#createNode", "scheme": "Hom", "type": "link"}, " method for more information\n    on the parameters."]}, {"indent": 4, "type": "para", "text": ["See also the ", {"_hs_sc": true, "fragment": "#createInputNode", "text": ["createInputNode"], "value": "/hom/hou/Node#createInputNode", "fullpath": "/hom/hou/Node#createInputNode", "scheme": "Hom", "type": "link"}, " method."]}], "indent": 0, "text": [{"text": ["createOutputNode(self, node_type_name, node_name=None, run_init_scripts=True, load_contents=True, bool exact_type_name=False)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::createOutputNode"}, "type": "methods_item", "id": "createOutputNode"}, {"body": [{"indent": 4, "type": "para", "text": ["Returns a tuple of all input names for this node. Names for input\n    connectors that are hidden are also included."]}], "indent": 0, "text": [{"text": ["inputNames(self)"], "type": "code"}, "  \u2192 tuple of ", {"text": ["str"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::inputNames"}, "type": "methods_item", "id": "inputNames"}, {"body": [{"indent": 4, "type": "para", "text": ["Returns a tuple of all input labels for this node. Labels for input\n    connectors that are hidden are also included."]}], "indent": 0, "text": [{"text": ["inputLabels(self)"], "type": "code"}, "  \u2192 tuple of ", {"text": ["str"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::inputLabels"}, "type": "methods_item", "id": "inputLabels"}, {"body": [{"indent": 4, "type": "para", "text": ["Returns a tuple of all output names for this node."]}], "indent": 0, "text": [{"text": ["outputNames(self)"], "type": "code"}, "  \u2192 tuple of ", {"text": ["str"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::outputNames"}, "type": "methods_item", "id": "outputNames"}, {"body": [{"indent": 4, "type": "para", "text": ["Returns a tuple of all output labels for this node."]}], "indent": 0, "text": [{"text": ["outputLabels(self)"], "type": "code"}, "  \u2192 tuple of ", {"text": ["str"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::outputLabels"}, "type": "methods_item", "id": "outputLabels"}], "container": true, "role": "item_group", "type": "methods_item_group"}], "indent": 0, "level": 2, "text": ["Inputs and outputs"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Return a tuple of nodes that are referenced by this node, either through\n    parameter expressions, referring to the node by name, or using expressions\n    which rely on the data generated by another node. These reflect all the\n    other ways (besides connecting to an input) in which one node may affect\n    another."]}], "indent": 0, "text": [{"text": ["references(self, include_children = True)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"_hs_sc": true, "text": "", "value": "/hom/hou/Node", "fallback_text": "hou.Node", "fullpath": "/hom/hou/Node", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::references"}, "type": "methods_item", "id": "references"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a tuple of nodes that are reference this node, either through\n    parameter expressions, referring to the node by name, or using expressions\n    which rely on the data generated by this node. These reflect all the\n    other ways (besides connecting to an input) in which one node may affect\n    another."]}], "indent": 0, "text": [{"text": ["dependents(self, include_children = True)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"_hs_sc": true, "text": "", "value": "/hom/hou/Node", "fallback_text": "hou.Node", "fullpath": "/hom/hou/Node", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::dependents"}, "type": "methods_item", "id": "dependents"}], "container": true, "role": "item_group", "type": "methods_item_group"}], "indent": 0, "level": 2, "text": ["Dependencies"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Return True if the node is a sub-network and False otherwise."]}], "indent": 0, "text": [{"text": ["isSubNetwork(self)"], "type": "code"}, "  \u2192 ", {"text": ["bool"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::isEditableInsideLockedHDA"}, "type": "methods_item", "id": "isSubNetwork"}, {"body": [{"indent": 4, "type": "para", "text": ["Given a sequence of children nodes of this node, collapse them into a\n    subnetwork.  In other words, create a subnet inside this node\u2019s network\n    and move the specified children of this network inside that subnet."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["The children nodes of this node that will go in the new subnet."]}], "indent": 4, "type": "dt", "text": ["child_nodes"]}, {"body": [{"indent": 8, "type": "para", "text": ["The name for the new subnet node, or None if you want Houdini to\n        automatically choose a name."]}], "indent": 4, "type": "dt", "text": ["subnet_name"]}, {"body": [{"indent": 8, "type": "para", "text": ["The type for the new subnet node, or None if you want Houdini to\n        automatically choose a primary subnetwork type, which is recommended."]}], "indent": 4, "type": "dt", "text": ["subnet_name"]}], "container": true, "type": "dt_group"}, {"indent": 4, "type": "para", "text": ["Raises ", {"_hs_sc": true, "text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if a node inside ", {"text": ["child_nodes"], "type": "code"}, " is not\n    a child of this network, or if ", {"text": ["child_nodes"], "type": "code"}, " is an empty sequence."]}, {"indent": 4, "type": "para", "text": ["This example function takes a single node and replaces it with a subnet,\n    moving the node into the subnet.."]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    def collapseSingleNodeIntoSubnet(node, subnet_name=None):\n        node.parent().collapseIntoSubnet((node,), subnet_name=None)\n    "]}], "indent": 0, "text": [{"text": ["collapseIntoSubnet(self, child_nodes, subnet_name=None, subnet_type=None)"], "type": "code"}, "  \u2192 ", {"_hs_sc": true, "text": "", "value": "/hom/hou/Node", "fallback_text": "hou.Node", "fullpath": "/hom/hou/Node", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::collapseIntoSubnet", "replaces": "/commands/opcollapse"}, "type": "methods_item", "id": "collapseIntoSubnet"}, {"body": [{"indent": 4, "type": "para", "text": ["Move the children of this subnet node to become siblings of this node, and\n    then delete this node.  The method is the opposite of\n    ", {"text": ["collapseIntoSubnet()"], "type": "code"}, "."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"_hs_sc": true, "text": "", "value": "/hom/hou/InvalidNodeType", "fallback_text": "hou.InvalidNodeType", "fullpath": "/hom/hou/InvalidNodeType", "scheme": "Hom", "type": "link"}, " if this node is not a subnetwork."]}], "indent": 0, "text": [{"text": ["extractAndDelete(self)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::extractAndDelete", "replaces": "/commands/opextract"}, "type": "methods_item", "id": "extractAndDelete"}], "container": true, "role": "item_group", "type": "methods_item_group"}], "indent": 0, "level": 2, "text": ["Subnets"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Return ", {"text": ["True"], "type": "code"}, " if ", {"_hs_sc": true, "fragment": "#createDigitalAsset", "text": "", "value": "/hom/hou/Node#createDigitalAsset", "fallback_text": "hou.Node.createDigitalAsset", "fullpath": "/hom/hou/Node#createDigitalAsset", "scheme": "Hom", "type": "link"}, " can succeed."]}], "indent": 0, "text": [{"text": ["canCreateDigitalAsset(self)"], "type": "code"}, "  \u2192 bool"], "role": "item", "attrs": {"cppname": "HOM_Node::canCreateDigitalAsset"}, "type": "methods_item", "id": "canCreateDigitalAsset"}, {"body": [{"indent": 4, "type": "para", "text": ["Create a digital asset from this node.  You would typically call this\n    method on subnet nodes."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["The name of the node type that the new digital asset will define."]}], "indent": 4, "type": "dt", "text": ["name"]}, {"body": [{"indent": 8, "type": "para", "text": ["The name of the hda file where Houdini will save the digital asset.\n        If ", {"text": ["None"], "type": "code"}, " Houdini will use ", {"text": ["$HOME/houdiniX.Y/hda/OPcustom.hda"], "type": "code"}, "."]}], "indent": 4, "type": "dt", "text": ["hda_file_name"]}, {"body": [{"indent": 8, "type": "para", "text": ["The name that will appear in the tab menu.  If None, Houdini will use\n        the name for the description."]}], "indent": 4, "type": "dt", "text": ["description"]}, {"body": [{"indent": 8, "type": "para", "text": ["The minimum number of inputs that need to be wired into instances of\n        the digital asset.  See ", {"_hs_sc": true, "fragment": "#minNumInputs", "text": "", "value": "/hom/hou/HDADefinition#minNumInputs", "fallback_text": "hou.HDADefinition.minNumInputs", "fullpath": "/hom/hou/HDADefinition#minNumInputs", "scheme": "Hom", "type": "link"}, " for more\n        information."]}], "indent": 4, "type": "dt", "text": ["min_num_inputs"]}, {"body": [{"indent": 8, "type": "para", "text": ["The number of input connectors available on instances of the digital\n        asset for input connections.  See ", {"_hs_sc": true, "fragment": "#minNumInputs", "text": "", "value": "/hom/hou/HDADefinition#minNumInputs", "fallback_text": "hou.HDADefinition.minNumInputs", "fullpath": "/hom/hou/HDADefinition#minNumInputs", "scheme": "Hom", "type": "link"}, "\n        for more information."]}], "indent": 4, "type": "dt", "text": ["max_num_inputs"]}, {"body": [{"indent": 8, "type": "para", "text": ["Whether or not the contents of this digital asset are compressed inside\n        the hda file.  See ", {"_hs_sc": true, "fragment": "#compressContents", "text": "", "value": "/hom/hou/HDAOptions#compressContents", "fallback_text": "hou.HDAOptions.compressContents", "fullpath": "/hom/hou/HDAOptions#compressContents", "scheme": "Hom", "type": "link"}, " for more\n        information."]}], "indent": 4, "type": "dt", "text": ["compress_contents"]}, {"body": [{"indent": 8, "type": "para", "text": ["A user-defined comment string.  See ", {"_hs_sc": true, "fragment": "#comment", "text": "", "value": "/hom/hou/HDADefinition#comment", "fallback_text": "hou.HDADefinition.comment", "fullpath": "/hom/hou/HDADefinition#comment", "scheme": "Hom", "type": "link"}, "\n        for more information."]}], "indent": 4, "type": "dt", "text": ["comment"]}, {"body": [{"indent": 8, "type": "para", "text": ["A user-defined version string.  See ", {"_hs_sc": true, "fragment": "#version", "text": "", "value": "/hom/hou/HDADefinition#version", "fallback_text": "hou.HDADefinition.version", "fullpath": "/hom/hou/HDADefinition#version", "scheme": "Hom", "type": "link"}, "\n        for more information."]}], "indent": 4, "type": "dt", "text": ["version"]}, {"body": [{"indent": 8, "type": "para", "text": ["Whether or not the digital asset\u2019s definition will be saved with the\n        hip file instead of an hda file.  When this parameter is True, Houdini\n        ignores the ", {"text": ["hda_file_name"], "type": "code"}, " parameter.  Setting this parameter to True\n        is equivalent to setting this parameter to False and setting the\n        ", {"text": ["hda_file_name"], "type": "code"}, " parameter to \"Embedded\"."]}], "indent": 4, "type": "dt", "text": ["save_as_embedded"]}, {"body": [{"indent": 8, "type": "para", "text": ["If True, Houdini will not generate warnings if the contents of this\n        digital asset reference nodes outside the asset."]}], "indent": 4, "type": "dt", "text": ["ignore_external_references"]}, {"body": [{"indent": 8, "type": "para", "text": ["Normally, Houdini will change the node creating the digital asset into\n        the new digital asset type.  Setting this flag to false will cause the\n        node to remain unchanged."]}], "indent": 4, "type": "dt", "text": ["change_node_type"]}], "container": true, "type": "dt_group"}], "indent": 0, "text": [{"text": ["createDigitalAsset(self, name=None, hda_file_name=None, description=None, min_num_inputs=None, max_num_inputs=None, compress_contents=False, comment=None, version=None, save_as_embedded=False, ignore_external_references=False, change_node_type=True)"], "type": "code"}, "  \u2192 ", {"text": ["Node"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::createDigitalAsset"}, "type": "methods_item", "id": "createDigitalAsset"}, {"body": [{"indent": 4, "type": "para", "text": ["Create a compiled digital asset from this node.  You would typically call\n    this method on vop network nodes, such as Material Shader Builder SHOP,\n    Surface Shader Builder SHOP, or VEX Surface SHOP Type VOPNET. The digital asset\n    does not have contents section, which means it does not have vop network inside,\n    but instead relies on the saved VEX code sections to provide the shader code."]}, {"indent": 4, "type": "para", "text": ["After the creation of a compiled HDA, if its VEX code section is ever\n    changed manually, the corresponding vex object code section can be\n    recompiled using ", {"_hs_sc": true, "fragment": "#compileCodeSection", "text": "", "value": "/hom/hou/HDADefinition#compileCodeSection", "fallback_text": "hou.HDADefinition.compileCodeSection", "fullpath": "/hom/hou/HDADefinition#compileCodeSection", "scheme": "Hom", "type": "link"}, "."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["The name of the node type that the new digital asset will define."]}], "indent": 4, "type": "dt", "text": ["name"]}, {"body": [{"indent": 8, "type": "para", "text": ["The name of the hda file where Houdini will save the digital asset.\n        If ", {"text": ["None"], "type": "code"}, " Houdini will use ", {"text": ["$HOME/houdiniX.Y/hda/OPcustom.hda"], "type": "code"}, "."]}], "indent": 4, "type": "dt", "text": ["hda_file_name"]}, {"body": [{"indent": 8, "type": "para", "text": ["The name that will appear in the tab menu.  If None, Houdini will use\n        the name for the description."]}], "indent": 4, "type": "dt", "text": ["description"]}], "container": true, "type": "dt_group"}], "indent": 0, "text": [{"text": ["createCompiledDigitalAsset(self, name=None, hda_file_name=None, description=None)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::createCompiledDigitalAsset", "replaces": "/commands/otcreatecompiledtypefrom"}, "type": "methods_item", "id": "createCompiledDigitalAsset"}, {"body": [{"indent": 4, "type": "para", "text": ["Unlocks a digital asset so its contents can be edited."]}, {"indent": 4, "type": "para", "text": ["To use this function, you must have permission to modify the HDA."]}], "indent": 0, "text": [{"text": ["allowEditingOfContents(self, propagate=False)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::allowEditingOfContents", "replaces": "/commands/otsync"}, "type": "methods_item", "id": "allowEditingOfContents"}, {"body": [{"indent": 4, "type": "para", "text": ["If this node is an unlocked digital asset, change its contents to match\n    what is stored in the definition and lock it.  The parameter values are\n    unchanged."]}, {"indent": 4, "type": "para", "text": ["If this node is locked or is not a digital asset, this method has no\n    effect."]}, {"indent": 4, "type": "para", "text": ["See also ", {"_hs_sc": true, "fragment": "#matchesCurrentDefinition", "text": "", "value": "/hom/hou/Node#matchesCurrentDefinition", "fallback_text": "hou.Node.matchesCurrentDefinition", "fullpath": "/hom/hou/Node#matchesCurrentDefinition", "scheme": "Hom", "type": "link"}, " and\n    ", {"_hs_sc": true, "fragment": "#isLocked", "text": "", "value": "/hom/hou/Node#isLocked", "fallback_text": "hou.Node.isLocked", "fullpath": "/hom/hou/Node#isLocked", "scheme": "Hom", "type": "link"}, "."]}], "indent": 0, "text": [{"text": ["matchCurrentDefinition(self)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::matchCurrentDefinition", "replaces": "/commands/otsync"}, "type": "methods_item", "id": "matchCurrentDefinition"}, {"body": [{"indent": 4, "type": "para", "text": ["Return whether the contents of the node are locked to its type definition."]}], "indent": 0, "text": [{"text": ["matchesCurrentDefinition(self)"], "type": "code"}, "  \u2192 ", {"text": ["bool"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::matchesCurrentDefinition", "replaces": "/commands/otsync"}, "type": "methods_item", "id": "matchesCurrentDefinition"}, {"body": [{"indent": 4, "type": "para", "text": ["If this node is an instance of a digital asset, return whether or not it\n    is locked.  Otherwise, return False."]}, {"indent": 4, "type": "para", "text": ["To differentiate between unlocked digital assets and nodes that are\n    not instances of digital assets, check if the node\u2019s type has a definition:"]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    def isUnlockedAsset(node):\n        return not node.isLockedHDA() and node.type().definition() is not None\n    "]}, {"indent": 4, "type": "para", "text": ["See ", {"_hs_sc": true, "fragment": "#updateFromNode", "text": "", "value": "/hom/hou/HDADefinition#updateFromNode", "fallback_text": "hou.HDADefinition.updateFromNode", "fullpath": "/hom/hou/HDADefinition#updateFromNode", "scheme": "Hom", "type": "link"}, " for an example of how to\n    save and lock all unlocked digital asset instances."]}], "indent": 0, "text": [{"text": ["isLockedHDA(self)"], "type": "code"}, "  \u2192 ", {"text": ["bool"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::isLockedHDA"}, "type": "methods_item", "id": "isLockedHDA"}, {"body": [{"indent": 4, "type": "para", "text": ["Return whether this node is inside a locked digital asset.  If this node is\n    not inside a locked HDA, the node may deviate from the HDA definition."]}], "indent": 0, "text": [{"text": ["isInsideLockedHDA(self)"], "type": "code"}, "  \u2192 ", {"text": ["bool"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::isInsideLockedHDA"}, "type": "methods_item", "id": "isInsideLockedHDA"}, {"body": [{"indent": 4, "type": "para", "text": ["Return True if the node is an editable node contained inside a locked HDA\n    node and False otherwise. In particular this function will return False\n    for a node that is not inside a locked HDA."]}], "indent": 0, "text": [{"text": ["isEditableInsideLockedHDA(self)"], "type": "code"}, "  \u2192 ", {"text": ["bool"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::isEditableInsideLockedHDA"}, "type": "methods_item", "id": "isEditableInsideLockedHDA"}, {"body": [{"indent": 4, "type": "para", "text": ["Return True if the node is editable. This is similar to the\n    ", {"_hs_sc": true, "fragment": "#isEditableInsideLockedHDA", "text": "", "value": "/hom/hou/Node#isEditableInsideLockedHDA", "fallback_text": "hou.Node.isEditableInsideLockedHDA", "fullpath": "/hom/hou/Node#isEditableInsideLockedHDA", "scheme": "Hom", "type": "link"}, " method except that it will return\n    True for nodes that are not inside a locked HDA. This function is the\n    simplest way to determine if most node modifications (changing inputs,\n    changing parameters, changing flags) will be allowed on the node."]}], "indent": 0, "text": [{"text": ["isEditable(self)"], "type": "code"}, "  \u2192 ", {"text": ["bool"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::isEditable"}, "type": "methods_item", "id": "isEditable"}, {"body": [{"indent": 4, "type": "para", "text": ["This method is a shortcut for `self.type().hdaModule() to reduce the length\n    of expressions in Python parameters and button callbacks.  See\n    ", {"_hs_sc": true, "fragment": "#hdaModule", "text": "", "value": "/hom/hou/NodeType#hdaModule", "fallback_text": "hou.NodeType.hdaModule", "fullpath": "/hom/hou/NodeType#hdaModule", "scheme": "Hom", "type": "link"}, " for more information."]}, {"indent": 4, "type": "para", "text": ["See also the ", {"text": ["hm"], "type": "code"}, " method and ", {"_hs_sc": true, "text": "", "value": "/hom/hou/phm", "fallback_text": "hou.phm", "fullpath": "/hom/hou/phm", "scheme": "Hom", "type": "link"}, "."]}], "indent": 0, "text": [{"text": ["hdaModule(self)"], "type": "code"}, "  \u2192 ", {"_hs_sc": true, "text": "", "value": "/hom/hou/HDAModule", "fallback_text": "hou.HDAModule", "fullpath": "/hom/hou/HDAModule", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::hdaModule"}, "type": "methods_item", "id": "hdaModule"}, {"body": [{"indent": 4, "type": "para", "text": ["This method is a shortcut for ", {"text": ["self.hdaModule()"], "type": "code"}, "."]}, {"indent": 4, "type": "para", "text": ["See also ", {"_hs_sc": true, "text": "", "value": "/hom/hou/phm", "fallback_text": "hou.phm", "fullpath": "/hom/hou/phm", "scheme": "Hom", "type": "link"}, "."]}], "indent": 0, "text": [{"text": ["hm(self)"], "type": "code"}, "  \u2192 ", {"_hs_sc": true, "text": "", "value": "/hom/hou/HDAModule", "fallback_text": "hou.HDAModule", "fullpath": "/hom/hou/HDAModule", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::hdaModule"}, "type": "methods_item", "id": "hm"}], "container": true, "role": "item_group", "type": "methods_item_group"}], "indent": 0, "level": 2, "text": ["Assets"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Return the node\u2019s comment string."]}], "indent": 0, "text": [{"text": ["comment(self)"], "type": "code"}, "  \u2192 ", {"text": ["str"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::comment", "replaces": "/commands/opcomment"}, "type": "methods_item", "id": "comment"}, {"body": [{"indent": 4, "type": "para", "text": ["Sets the comment associated with this node.\n    See also ", {"text": ["appendComment()"], "type": "code"}, "."]}], "indent": 0, "text": [{"text": ["setComment(self, comment)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::setComment", "replaces": "/commands/opcomment"}, "type": "methods_item", "id": "setComment"}, {"body": [{"indent": 4, "type": "para", "text": ["Appends the given text to the comment associated with this node."]}], "indent": 0, "text": [{"text": ["appendComment(self, comment)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::appendComment", "replaces": "/commands/opcomment"}, "type": "methods_item", "id": "appendComment"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a boolean to indicate of the node should display its\n    descriptive name in the network editor."]}], "indent": 0, "text": [{"text": ["isDisplayDescriptiveNameFlagSet(self)"], "type": "code"}, "  \u2192 ", {"text": ["bool"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::isDisplayDescriptiveNameFlagSet", "replaces": "/commands/opget /expressions/opflag"}, "type": "methods_item", "id": "isDisplayDescriptiveNameFlagSet"}, {"body": [{"indent": 4, "type": "para", "text": ["Set or unset whether this node should display its descriptive\n    name in the network editor."]}], "indent": 0, "text": [{"text": ["setDisplayDescriptiveNameFlag(self, on)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::setDisplayDescriptiveName", "replaces": "/commands/opset"}, "type": "methods_item", "id": "setDisplayDescriptiveNameFlag"}, {"body": [{"indent": 4, "type": "para", "text": ["Return the date and time when the node was created."]}], "indent": 0, "text": [{"text": ["creationTime(self)"], "type": "code"}, "  \u2192 ", {"text": ["datetime.datetime"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::creationTime", "replaces": "/commands/opstat"}, "type": "methods_item", "id": "creationTime"}, {"body": [{"indent": 4, "type": "para", "text": ["Return the date and time when the node was last modified."]}], "indent": 0, "text": [{"text": ["modificationTime(self)"], "type": "code"}, "  \u2192 ", {"text": ["datetime.datetime"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::modificationTime", "replaces": "/commands/opstat"}, "type": "methods_item", "id": "modificationTime"}, {"body": [], "indent": 0, "text": [{"text": ["creator(self)"], "type": "code"}, "  \u2192 Node"], "role": "item", "attrs": {"status": "nd", "cppname": "HOM_Node::creator", "replaces": "/commands/opstat"}, "type": "methods_item", "id": "creator"}, {"body": [{"indent": 4, "type": "para", "text": ["This returns the name of the viewport tool that was used to be created.\n    This name is not set by default and is usually the empty string."]}], "indent": 0, "text": [{"text": ["creatorState(self)"], "type": "code"}, "  \u2192 ", {"text": ["str"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::creatorState"}, "type": "methods_item", "id": "creatorState"}, {"body": [{"indent": 4, "type": "para", "text": ["This sets the name of the tool that created this node. If you call this\n    with a name that differs from the node type name, you should also call\n    ", {"text": ["setBuiltExplicitly(False)"], "type": "code"}, "."]}], "indent": 0, "text": [{"text": ["setCreatorState(self, state)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::setCreatorState"}, "type": "methods_item", "id": "setCreatorState"}, {"body": [{"indent": 4, "type": "para", "text": ["Return whether this node was built explicitly (defaults to True).  Most\n    nodes are built explicitly, but some are implicitly created by Houdini.\n    For example, if you select geometry from multiple SOPs and then perform\n    an operation, Houdini will put down an implicit merge SOP before performing\n    that operation.  When reselecting geometry in SOPs, Houdini will\n    automatically delete any SOPs that were created implicitly."]}], "indent": 0, "text": [{"text": ["isBuiltExplicitly(self)"], "type": "code"}, "  \u2192 ", {"text": ["bool"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::creator"}, "type": "methods_item", "id": "isBuiltExplicitly"}, {"body": [{"indent": 4, "type": "para", "text": ["Set whether this node was built explicitly (default value is True). If\n    set to False, this node will not show up in various menus and in the\n    Network View pane\u2019s list mode. This flag is typically used for\n    intermediate utility nodes that one is unlikely to want to change its\n    parameters."]}], "indent": 0, "text": [{"text": ["setBuiltExplicitly(self, built_explicitly)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::setBuiltExplicitly()"}, "type": "methods_item", "id": "setBuiltExplicitly"}, {"body": [{"indent": 4, "type": "para", "text": ["Return whether the node is time dependent.  A time dependent node is\n    re-evaluated every time the frame changes."]}], "indent": 0, "text": [{"text": ["isTimeDependent(self)"], "type": "code"}, "  \u2192 ", {"text": ["bool"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::isTimeDependent"}, "type": "methods_item", "id": "isTimeDependent"}], "container": true, "role": "item_group", "type": "methods_item_group"}], "indent": 0, "level": 2, "text": ["Metadata"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Moves a node to a well-spaced position near its inputs or outputs and\n    returns the new position of the node."]}], "indent": 0, "text": [{"text": ["moveToGoodPosition(self, relative_to_inputs=True, move_inputs=True, move_outputs=True, move_unconnected=True)"], "type": "code"}, "  \u2192 ", {"_hs_sc": true, "text": "", "value": "/hom/hou/Vector2", "fallback_text": "hou.Vector2", "fullpath": "/hom/hou/Vector2", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::moveToGoodPosition", "replaces": "/commands/opautoplace"}, "type": "methods_item", "id": "moveToGoodPosition"}, {"body": [{"indent": 4, "type": "para", "text": ["Automatically position all or some children of this node in the network\n    editor."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["A sequence of child ", {"_hs_sc": true, "text": "", "value": "/hom/hou/NetworkMovableItem", "fallback_text": "hou.NetworkMovableItem", "fullpath": "/hom/hou/NetworkMovableItem", "scheme": "Hom", "type": "link"}, " objects to position.\n        This may include nodes, dots, and/or subnet inputs. If this sequence\n        is empty, this method will reposition all child items of this node."]}], "indent": 4, "type": "dt", "text": ["items"]}, {"body": [{"indent": 8, "type": "para", "text": ["A fraction of the width and height of a tile that affects the space\n        between nodes with common inputs.  If this parameter is -1, Houdini\n        uses the default spacing."]}], "indent": 4, "type": "dt", "text": ["horizontal_spacing"]}, {"body": [{"indent": 8, "type": "para", "text": ["A fraction of the width and height of a tile that affects the space\n        between a node and its output nodes.  If this parameter is -1, Houdini\n        uses the default spacing."]}], "indent": 4, "type": "dt", "text": ["vertical_spacing"]}], "container": true, "type": "dt_group"}], "indent": 0, "text": [{"text": ["layoutChildren(self, child_nodes=(), horizontal_spacing=-1.0, vertical_spacing=-1.0)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::layoutChildren", "replaces": "/commands/oplayout"}, "type": "methods_item", "id": "layoutChildren"}, {"body": [{"indent": 4, "type": "para", "text": ["Return whether the node is hidden in the network editor.  Note that Houdini\n    also uses the term \"exposed\" to refer to nodes that are not hidden."]}, {"indent": 4, "type": "para", "text": ["If a visible node is connected to a hidden node, the network editor will\n    display dashed lines for the wire going from the visible node to the hidden\n    node."]}, {"indent": 4, "type": "para", "text": ["See also ", {"_hs_sc": true, "fragment": "#hide", "text": "", "value": "/hom/hou/Node#hide", "fallback_text": "hou.Node.hide", "fullpath": "/hom/hou/Node#hide", "scheme": "Hom", "type": "link"}, "."]}], "indent": 0, "text": [{"text": ["isHidden(self)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::isHidden", "replaces": "/commands/opget /expressions/opflag"}, "type": "methods_item", "id": "isHidden"}, {"body": [{"indent": 4, "type": "para", "text": ["Hide or show a node in the network editor.  See ", {"_hs_sc": true, "fragment": "#isHidden", "text": "", "value": "/hom/hou/Node#isHidden", "fallback_text": "hou.Node.isHidden", "fullpath": "/hom/hou/Node#isHidden", "scheme": "Hom", "type": "link"}, "\n    for more information about hidden nodes."]}], "indent": 0, "text": [{"text": ["hide(self, on)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::hide", "replaces": "/commands/opset"}, "type": "methods_item", "id": "hide"}], "container": true, "role": "item_group", "type": "methods_item_group"}], "indent": 0, "level": 2, "text": ["Layout"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Asks or forces the node to re-cook."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["The frames at which to cook the object. This should be a tuple of 2 or 3\n        ints giving the start frame, end frame, and optionally a frame\n        increment, in that order. If you supply a two-tuple ", {"text": ["(start, end)"], "type": "code"}, ", the\n        increment is ", {"text": ["1"], "type": "code"}, "."]}], "indent": 4, "type": "dt", "text": ["frame_range"]}], "container": true, "type": "dt_group"}], "indent": 0, "text": [{"text": ["cook(self, force=False, frame_range=())"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::cook", "replaces": "/commands/opcook"}, "type": "methods_item", "id": "cook"}, {"body": [{"indent": 4, "type": "para", "text": ["Asks if the node needs to re-cook."]}], "indent": 0, "text": [{"text": ["needsToCook(self, time=hou.time())"], "type": "code"}, "  \u2192 ", {"text": ["bool"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::needsToCook"}, "type": "methods_item", "id": "needsToCook"}, {"body": [{"indent": 4, "type": "para", "text": ["Returns the number of times this node has cooked in the current session."]}], "indent": 0, "text": [{"text": ["cookCount(self)"], "type": "code"}, "  \u2192 ", {"text": ["int"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::cookCount()"}, "type": "methods_item", "id": "cookCount"}, {"body": [{"indent": 4, "type": "para", "text": ["Update the UI states, such as hidden and disabled, for each parameter\n    in the node."]}, {"indent": 4, "type": "para", "text": ["UI states can be expressed as conditionals (i.e. Disable\n    When) which require evaluation.  Typically in graphical Houdini the\n    Parameter Pane performs the evaluation when the node is selected in order\n    to determine how the node parameters should look in the pane.  However in\n    non-graphical Houdini or if the Parameter Pane has not yet loaded the node,\n    then the evaluation does not occur and the UI states remain at their\n    defaults causing methods such as ", {"_hs_sc": true, "fragment": "#isDisabled", "text": "", "value": "/hom/hou/Parm#isDisabled", "fallback_text": "hou.Parm.isDisabled", "fullpath": "/hom/hou/Parm#isDisabled", "scheme": "Hom", "type": "link"}, " and\n    ", {"_hs_sc": true, "fragment": "#isHidden", "text": "", "value": "/hom/hou/Parm#isHidden", "fallback_text": "hou.Parm.isHidden", "fullpath": "/hom/hou/Parm#isHidden", "scheme": "Hom", "type": "link"}, " to return incorrect values.  In these cases, it\n    is recommended that ", {"_hs_sc": true, "fragment": "#updateParmStates", "text": "", "value": "/hom/hou/Node#updateParmStates", "fallback_text": "hou.Node.updateParmStates", "fullpath": "/hom/hou/Node#updateParmStates", "scheme": "Hom", "type": "link"}, " is called."]}], "indent": 0, "text": [{"text": ["updateParmStates(self)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::updateParmStates()"}, "type": "methods_item", "id": "updateParmStates"}, {"body": [{"indent": 4, "type": "para", "text": ["Return the text of any errors from the last cook of this node,\n    or an empty tuple if there were no errors."]}], "indent": 0, "text": [{"text": ["errors(self)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"text": ["str"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::errors"}, "type": "methods_item", "id": "errors"}, {"body": [{"indent": 4, "type": "para", "text": ["Return the text of any warnings from the last cook of this node,\n    or an empty tuple if there were no warnings."]}], "indent": 0, "text": [{"text": ["warnings(self)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"text": ["str"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::warnings"}, "type": "methods_item", "id": "warnings"}, {"body": [{"indent": 4, "type": "para", "text": ["Return the text of any messages from the last cook of this node,\n    or an empty tuple if there were no messages."]}], "indent": 0, "text": [{"text": ["messages(self)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"text": ["str"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::messages"}, "type": "methods_item", "id": "messages"}, {"body": [{"indent": 4, "type": "para", "text": ["Returns a tree structure containing information about the node and its\n    most recently cooked data. The contents of the tree vary widely depending\n    on the node type, and the nature of its cooked data. This tree of data is\n    used to generate the node information window contents."]}, {"indent": 4, "type": "para", "text": ["Setting ", {"text": ["verbose"], "type": "code"}, " to ", {"text": ["True"], "type": "code"}, " will cause some additional information to be\n    generated. In particular data that is expensive to calculate, or which will\n    generate a large amount of information tends to be generated only if this\n    option is turned on."]}, {"indent": 4, "type": "para", "text": ["Setting ", {"text": ["debug"], "type": "code"}, " to ", {"text": ["True"], "type": "code"}, " will, in a few cases, cause additional\n    information to be displayed which generally will be most useful when\n    debugging the internal opreation of Houdini. For example, geometry\n    attributes will display their \"data ids\", which can be helpful when\n    tracking down errors in SOPs written with the HDK."]}], "indent": 0, "text": [{"text": ["infoTree(self, verbose=False, debug=False)"], "type": "code"}, "  \u2192 ", {"_hs_sc": true, "text": "", "value": "/hom/hou/NodeInfoTree", "fallback_text": "hou.NodeInfoTree", "fullpath": "/hom/hou/NodeInfoTree", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::infoTree", "replaces": "/commands/opinfo"}, "type": "methods_item", "id": "infoTree"}, {"body": [{"indent": 4, "type": "para", "text": ["Return True if the node can generate compiled cook code and False otherwise."]}, {"indent": 4, "type": "para", "text": ["If check_parent is true, the parents in the ancestor hierarchy are tested\n    if any of them can generate code."]}], "indent": 0, "text": [{"text": ["canGenerateCookCode(self, check_parent=False)"], "type": "code"}, "  \u2192 ", {"text": ["bool"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::canGenerateCookCode"}, "type": "methods_item", "id": "canGenerateCookCode"}, {"body": [{"indent": 4, "type": "para", "text": ["Return the node itself or a network node that contains this node and \n    can generate compiled cook code.  For example, the generator node for \n    a VOP node could be the SHOP node or SOP node that contains it for example."]}, {"indent": 4, "type": "para", "text": ["Return None if this node cannot generate code and is not contained \n    in a code generating node either either."]}], "indent": 0, "text": [{"text": ["cookCodeGeneratorNode(self, check_parent=False)"], "type": "code"}, "  \u2192 ", {"_hs_sc": true, "text": "", "value": "/hom/hou/Node", "fallback_text": "hou.Node", "fullpath": "/hom/hou/Node", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::cookCodeGeneratorNode"}, "type": "methods_item", "id": "cookCodeGeneratorNode"}, {"body": [{"indent": 4, "type": "para", "text": ["Return the language of the generated cook code (i.e. VEX, RSL)."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"_hs_sc": true, "text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if this node cannot generate compiled code."]}], "indent": 0, "text": [{"text": ["cookCodeLanguage(self)"], "type": "code"}, "  \u2192 ", {"text": ["str"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::cookCodeLanguage"}, "type": "methods_item", "id": "cookCodeLanguage"}, {"body": [{"indent": 4, "type": "para", "text": ["Return True if this node can generate compiled cook code for multiple\n    contexts (i.e. surface context, displacement context, etc.) and False otherwise."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"_hs_sc": true, "text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if this node cannot generate compiled code."]}], "indent": 0, "text": [{"text": ["supportsMultiCookCodeContexts(self)"], "type": "code"}, "  \u2192 ", {"text": ["bool"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::supportsMultiCookCodeContexts"}, "type": "methods_item", "id": "supportsMultiCookCodeContexts"}, {"body": [{"indent": 4, "type": "para", "text": ["Saves compiled VEX code to a disk file (for nodes that support this).\n    See ", {"_hs_sc": true, "fragment": "#saveCookCodeToFile", "text": "", "value": "/hom/hou/Node#saveCookCodeToFile", "fallback_text": "hou.Node.saveCookCodeToFile", "fullpath": "/hom/hou/Node#saveCookCodeToFile", "scheme": "Hom", "type": "link"}, " for a description of the arguments."]}], "indent": 0, "text": [{"text": ["saveCompiledCookCodeToFile(self, file_name, context_name=None)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::saveCompiledCookCodeToFile"}, "type": "methods_item", "id": "saveCompiledCookCodeToFile"}, {"body": [{"indent": 4, "type": "para", "text": ["Saves VEX/RSL source code to a disk file (on nodes that support this)."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["The file path in which to save the generated code."]}], "indent": 4, "type": "dt", "text": [{"text": ["file_name"], "type": "code"}]}, {"body": [{"indent": 8, "type": "para", "text": ["If ", {"text": ["True"], "type": "code"}, ", the method does not write a header comment at the beginning\n        of the file containing the file name and node path from which the code\n        was generated and a time stamp."]}], "indent": 4, "type": "dt", "text": [{"text": ["skip_header"], "type": "code"}]}, {"body": [{"indent": 8, "type": "para", "text": ["A string containing name of the shader context for the code. This\n        option applies to nodes such as the\n        ", {"_hs_sc": true, "text": ["Material Shader Builder"], "value": "/nodes/shop/vopmaterial", "fullpath": "/nodes/shop/vopmaterial", "scheme": "Node", "type": "link"}, " which can generate\n        code for multiple context types."]}, {"indent": 8, "type": "para", "text": ["For example, a Material network might contain both surface and\n        displacement shaders, so you must specify which type of shader code to\n        generate:"]}, {"lang": "python", "indent": 8, "type": "pre", "text": ["\n        node(\"/shop/vopmaterial1\").saveCookCodeToFile(\"myfile.vfl\", context_name=\"surface\")\n        "]}, {"indent": 8, "type": "para", "text": ["On single-context nodes this argument is ignored."]}, {"indent": 8, "type": "para", "text": ["For VEX materials, possible values are ", {"text": ["surface"], "type": "code"}, ", ", {"text": ["displacement"], "type": "code"}, ",\n        ", {"text": ["light"], "type": "code"}, ", ", {"text": ["shadow"], "type": "code"}, ", ", {"text": ["fog"], "type": "code"}, ", ", {"text": ["image3d"], "type": "code"}, ", ", {"text": ["photon"], "type": "code"}, ", or ", {"text": ["cvex"], "type": "code"}, "."]}, {"indent": 8, "type": "para", "text": ["For RSL materials, possible values are ", {"text": ["surface"], "type": "code"}, ", ", {"text": ["displacement"], "type": "code"}, ",\n        ", {"text": ["light"], "type": "code"}, ", ", {"text": ["volume"], "type": "code"}, ", or ", {"text": ["imager"], "type": "code"}, "."]}], "indent": 4, "type": "dt", "text": [{"text": ["context_name"], "type": "code"}]}], "container": true, "type": "dt_group"}], "indent": 0, "text": [{"text": ["saveCookCodeToFile(self, file_name, skip_header=False, context_name=None)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::saveCookCodeToFile"}, "type": "methods_item", "id": "saveCookCodeToFile"}], "container": true, "role": "item_group", "type": "methods_item_group"}], "indent": 0, "level": 2, "text": ["Cooking"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Return a list of the network boxes inside this node."]}], "indent": 0, "text": [{"text": ["networkBoxes(self)"], "type": "code"}, "  \u2192 tuple of ", {"_hs_sc": true, "text": "", "value": "/hom/hou/NetworkBox", "fallback_text": "hou.NetworkBox", "fullpath": "/hom/hou/NetworkBox", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::networkBoxes", "replaces": "/commands/nbls"}, "type": "methods_item", "id": "networkBoxes"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a generator that iterates through all the network boxes inside this\n    node."]}], "indent": 0, "text": [{"text": ["iterNetworkBoxes(self)"], "type": "code"}, "  \u2192 generator of ", {"_hs_sc": true, "text": "", "value": "/hom/hou/NetworkBox", "fallback_text": "hou.NetworkBox", "fullpath": "/hom/hou/NetworkBox", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::networkBoxes", "replaces": "/commands/nbls"}, "type": "methods_item", "id": "iterNetworkBoxes"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a network box with the given name inside this node, or ", {"text": ["None"], "type": "code"}, " if\n    no network box with the given name exists."]}], "indent": 0, "text": [{"text": ["findNetworkBox(self, name)"], "type": "code"}, "  \u2192 ", {"_hs_sc": true, "text": "", "value": "/hom/hou/NetworkBox", "fallback_text": "hou.NetworkBox", "fullpath": "/hom/hou/NetworkBox", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::findNetworkBox", "replaces": "/commands/nbls"}, "type": "methods_item", "id": "findNetworkBox"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a list of network boxes inside this node whose names match a\n    pattern."]}], "indent": 0, "text": [{"text": ["findNetworkBoxes(self, pattern)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"_hs_sc": true, "text": "", "value": "/hom/hou/NetworkBox", "fallback_text": "hou.NetworkBox", "fullpath": "/hom/hou/NetworkBox", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::findNetworkBoxes", "replaces": "/commands/nbglob"}, "type": "methods_item", "id": "findNetworkBoxes"}, {"body": [{"indent": 4, "type": "para", "text": ["Creates a network box inside this network. Raises ", {"_hs_sc": true, "text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, "\n    if this node is not a network."]}, {"indent": 4, "type": "para", "text": ["If you don\u2019t specify a ", {"text": ["name"], "type": "code"}, ", Houdini gives the box a default name."]}], "indent": 0, "text": [{"text": ["createNetworkBox(self, name=None)"], "type": "code"}, "  \u2192 ", {"_hs_sc": true, "text": "", "value": "/hom/hou/NetworkBox", "fallback_text": "hou.NetworkBox", "fullpath": "/hom/hou/NetworkBox", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::createNetworkBox", "replaces": "/commands/nbadd"}, "type": "methods_item", "id": "createNetworkBox"}, {"body": [{"indent": 4, "type": "para", "text": ["Copies a network box and returns the copy."]}, {"indent": 4, "type": "para", "text": ["If ", {"text": ["new_name"], "type": "code"}, " is given, the network box will be copied to a new network box\n    named new_name (a different name will be generated if there is already a\n    network box with that name)."]}, {"indent": 4, "type": "para", "text": ["If ", {"text": ["channel_reference_original"], "type": "code"}, " is ", {"text": ["True"], "type": "code"}, ", all operators created by the copy\n    will have their animatable parameters set to reference the original\n    operators."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"_hs_sc": true, "text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if this node is not a network or if the\n    node child type does not match the network box\u2019s node type."]}], "indent": 0, "text": [{"text": ["copyNetworkBox(self, network_box_to_copy, new_name=None, channel_reference_original=False)"], "type": "code"}, "  \u2192 ", {"_hs_sc": true, "text": "", "value": "/hom/hou/NetworkBox", "fallback_text": "hou.NetworkBox", "fullpath": "/hom/hou/NetworkBox", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::copyNetworkBox", "replaces": "/commands/nbcp"}, "type": "methods_item", "id": "copyNetworkBox"}], "container": true, "role": "item_group", "type": "methods_item_group"}], "indent": 0, "level": 2, "text": ["Network boxes"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Return a list of the sticky notes inside this node."]}], "indent": 0, "text": [{"text": ["stickyNotes(self)"], "type": "code"}, "  \u2192 tuple of ", {"_hs_sc": true, "text": "", "value": "/hom/hou/StickyNote", "fallback_text": "hou.StickyNote", "fullpath": "/hom/hou/StickyNote", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::stickyNotes"}, "type": "methods_item", "id": "stickyNotes"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a generator that iterates through all the sticky notes inside this\n    node."]}], "indent": 0, "text": [{"text": ["iterStickyNotes(self)"], "type": "code"}, "  \u2192 generator of ", {"_hs_sc": true, "text": "", "value": "/hom/hou/StickyNote", "fallback_text": "hou.StickyNote", "fullpath": "/hom/hou/StickyNote", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::stickyNotes"}, "type": "methods_item", "id": "iterStickyNotes"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a sticky note with the given name inside this node, or ", {"text": ["None"], "type": "code"}, " if\n    no sticky note with the given name exists."]}], "indent": 0, "text": [{"text": ["findStickyNote(self, name)"], "type": "code"}, "  \u2192 ", {"_hs_sc": true, "text": "", "value": "/hom/hou/StickyNote", "fallback_text": "hou.StickyNote", "fullpath": "/hom/hou/StickyNote", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::findStickyNote"}, "type": "methods_item", "id": "findStickyNote"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a list of sticky notes inside this node whose names match a\n    pattern."]}], "indent": 0, "text": [{"text": ["findStickyNotes(self, pattern)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"_hs_sc": true, "text": "", "value": "/hom/hou/StickyNote", "fallback_text": "hou.StickyNote", "fullpath": "/hom/hou/StickyNote", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::findStickyNotes"}, "type": "methods_item", "id": "findStickyNotes"}, {"body": [{"indent": 4, "type": "para", "text": ["Creates a sticky note inside this network. Raises ", {"_hs_sc": true, "text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, "\n    if this node is not a network."]}, {"indent": 4, "type": "para", "text": ["If you don\u2019t specify a ", {"text": ["name"], "type": "code"}, ", Houdini gives the note a default name."]}], "indent": 0, "text": [{"text": ["createStickyNote(self, name=None)"], "type": "code"}, "  \u2192 ", {"_hs_sc": true, "text": "", "value": "/hom/hou/StickyNote", "fallback_text": "hou.StickyNote", "fullpath": "/hom/hou/StickyNote", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::createStickyNote"}, "type": "methods_item", "id": "createStickyNote"}, {"body": [{"indent": 4, "type": "para", "text": ["Copies a sticky note and returns the copy."]}, {"indent": 4, "type": "para", "text": ["If ", {"text": ["new_name"], "type": "code"}, " is given, the sticky note will be copied to a new sticky note\n    named new_name (a different name will be generated if there is already a\n    sticky note with that name)."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"_hs_sc": true, "text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if this node is not a network or if the\n    node child type does not match the sticky note\u2019s node type."]}], "indent": 0, "text": [{"text": ["copyStickyNote(self, network_box_to_copy, new_name=None)"], "type": "code"}, "  \u2192 ", {"_hs_sc": true, "text": "", "value": "/hom/hou/StickyNote", "fallback_text": "hou.StickyNote", "fullpath": "/hom/hou/StickyNote", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::copyStickyNote"}, "type": "methods_item", "id": "copyStickyNote"}], "container": true, "role": "item_group", "type": "methods_item_group"}], "indent": 0, "level": 2, "text": ["Sticky notes"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Creates a network dot inside this network. Raises ", {"_hs_sc": true, "text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, "\n    if this node is not a network."]}], "indent": 0, "text": [{"text": ["createNetworkDot(self)"], "type": "code"}, "  \u2192 ", {"_hs_sc": true, "text": "", "value": "/hom/hou/NetworkDot", "fallback_text": "hou.NetworkDot", "fullpath": "/hom/hou/NetworkDot", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::createNetworkDot"}, "type": "methods_item", "id": "createNetworkDot"}, {"body": [{"indent": 4, "type": "para", "text": ["Returns a tuple of all dots in this network."]}], "indent": 0, "text": [{"text": ["networkDots(self)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"_hs_sc": true, "text": "", "value": "/hom/hou/NetworkDot", "fallback_text": "hou.NetworkDot", "fullpath": "/hom/hou/NetworkDot", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::networkDots"}, "type": "methods_item", "id": "networkDots"}], "container": true, "role": "item_group", "type": "methods_item_group"}], "indent": 0, "level": 2, "text": ["Network dots"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Add a node group to the node and return the new group."]}, {"indent": 4, "type": "para", "text": ["If a group of the given name already exists then this function simply\n    returns the existing group without adding a new one. If the name of the\n    group is None or an empty string, then a unique default name is\n    automatically chosen."]}, {"indent": 4, "type": "para", "text": ["This function can only be called on nodes that are networks. If it is called\n    on a node that is not a network, then it raises ", {"_hs_sc": true, "text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, "."]}, {"indent": 4, "type": "para", "text": ["To remove a node group, use ", {"_hs_sc": true, "fragment": "#destroy", "text": "", "value": "/hom/hou/NodeGroup#destroy", "fallback_text": "hou.NodeGroup.destroy", "fullpath": "/hom/hou/NodeGroup#destroy", "scheme": "Hom", "type": "link"}, "."]}], "indent": 0, "text": [{"text": ["addNodeGroup(self, name=None)"], "type": "code"}, "  \u2192 ", {"_hs_sc": true, "text": "", "value": "/hom/hou/NodeGroup", "fallback_text": "hou.NodeGroup", "fullpath": "/hom/hou/NodeGroup", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::addNodeGroup", "replaces": "/commands/opgadd"}, "type": "methods_item", "id": "addNodeGroup"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a node group contained by the node with the given name, or ", {"text": ["None"], "type": "code"}, " if\n    the group does not exist."]}], "indent": 0, "text": [{"text": ["nodeGroup(self, name)"], "type": "code"}, "  \u2192 ", {"_hs_sc": true, "text": "", "value": "/hom/hou/NodeGroup", "fallback_text": "hou.NodeGroup", "fullpath": "/hom/hou/NodeGroup", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::nodeGroup", "replaces": "/commands/opgls"}, "type": "methods_item", "id": "nodeGroup"}, {"body": [{"indent": 4, "type": "para", "text": ["Return the list of node groups in this node."]}], "indent": 0, "text": [{"text": ["nodeGroups(self)"], "type": "code"}, "  \u2192 tuple of ", {"_hs_sc": true, "text": "", "value": "/hom/hou/NodeGroup", "fallback_text": "hou.NodeGroup", "fullpath": "/hom/hou/NodeGroup", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::nodeGroups", "replaces": "/commands/opgls"}, "type": "methods_item", "id": "nodeGroups"}], "container": true, "role": "item_group", "type": "methods_item_group"}], "indent": 0, "level": 2, "text": ["Node groups"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Runs the initialization script associated with this node\u2019s type."]}], "indent": 0, "text": [{"text": ["runInitScripts(self)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::runInitScripts"}, "type": "methods_item", "id": "runInitScripts"}, {"body": [{"indent": 4, "type": "para", "text": ["Return the script that will run when this node is deleted."]}], "indent": 0, "text": [{"text": ["deleteScript(self)"], "type": "code"}, "  \u2192 ", {"text": ["str"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::deleteScript", "replaces": "/commands/opdelscript"}, "type": "methods_item", "id": "deleteScript"}, {"body": [{"indent": 4, "type": "para", "text": ["Sets the script that will run when this node is deleted."]}], "indent": 0, "text": [{"text": ["setDeleteScript(self, script_text, language=hou.scriptLanguage.Python)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::setDeleteScript"}, "type": "methods_item", "id": "setDeleteScript"}], "container": true, "role": "item_group", "type": "methods_item_group"}], "indent": 0, "level": 2, "text": ["Scripts"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Return a node path representing the location for storing clips. This\n    location may or may not exist. To find or create such a network, use\n    ", {"_hs_sc": true, "fragment": "#findOrCreateMotionEffectsNetwork", "text": "", "value": "/hom/hou/Node#findOrCreateMotionEffectsNetwork", "fallback_text": "hou.Node.findOrCreateMotionEffectsNetwork", "fullpath": "/hom/hou/Node#findOrCreateMotionEffectsNetwork", "scheme": "Hom", "type": "link"}, "."]}], "indent": 0, "text": [{"text": ["motionEffectsNetworkPath(self)"], "type": "code"}, "  \u2192 ", {"text": ["str"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::motionEffectsNetworkPath"}, "type": "methods_item", "id": "motionEffectsNetworkPath"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a CHOP network node suitable for storing Motion Effects. By\n    default, if the node doesn\u2019t exist, it will be created."]}, {"indent": 4, "type": "para", "text": ["See also ", {"_hs_sc": true, "fragment": "#storeAsClip", "text": "", "value": "/hom/hou/Parm#storeAsClip", "fallback_text": "hou.Parm.storeAsClip", "fullpath": "/hom/hou/Parm#storeAsClip", "scheme": "Hom", "type": "link"}, " and\n    ", {"_hs_sc": true, "fragment": "#motionEffectsNetworkPath", "text": "", "value": "/hom/hou/Node#motionEffectsNetworkPath", "fallback_text": "hou.Node.motionEffectsNetworkPath", "fullpath": "/hom/hou/Node#motionEffectsNetworkPath", "scheme": "Hom", "type": "link"}, "."]}], "indent": 0, "text": [{"text": ["findOrCreateMotionEffectsNetwork(self, create=True)"], "type": "code"}, "  \u2192 ", {"_hs_sc": true, "text": "", "value": "/hom/hou/chopNetNodeTypeCategory", "fallback_text": "hou.chopNetNodeTypeCategory", "fullpath": "/hom/hou/chopNetNodeTypeCategory", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Node::findOrCreateMotionEffectsNetwork"}, "type": "methods_item", "id": "findOrCreateMotionEffectsNetwork"}], "container": true, "role": "item_group", "type": "methods_item_group"}], "indent": 0, "level": 2, "text": ["Motion FX"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Return a copy stamping floating point or string value.  This node must be a\n    downstream stamping operator, such as a Copy SOP, Cache SOP, LSystem SOP,\n    or Copy CHOP."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["The name of the stamping variable."]}], "indent": 4, "type": "dt", "text": [{"text": ["parm_name"], "type": "code"}]}, {"body": [{"indent": 8, "type": "para", "text": ["The value that this function returns if Houdini is not currently\n        performing stamping, or if ", {"text": ["parm_name"], "type": "code"}, " is not a valid variable\n        name.  This value may be a float or a string."]}], "indent": 4, "type": "dt", "text": [{"text": ["default_value"], "type": "code"}]}], "container": true, "type": "dt_group"}, {"indent": 4, "type": "para", "text": ["You might put the following expression in a Python parameter:"]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    node(\"../copy1\").stampValue(\"sides\", 5)\n    "]}], "indent": 0, "text": [{"text": ["stampValue(self, parm_name, default_value)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::stampValue", "replaces": "/expressions/stamp /expressions/stamps"}, "type": "methods_item", "id": "stampValue"}], "container": true, "role": "item_group", "type": "methods_item_group"}], "indent": 0, "level": 2, "text": ["Stamping"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Given a sequence of child items (nodes, network boxes, sticky notes, etc),\n    save them to the clipboard so they can be pasted into this or another\n    network."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["A sequence of ", {"_hs_sc": true, "text": "", "value": "/hom/hou/NetworkMovableItem", "fallback_text": "hou.NetworkMovableItem", "fullpath": "/hom/hou/NetworkMovableItem", "scheme": "Hom", "type": "link"}, "s that are children of this\n        node."]}], "indent": 4, "type": "dt", "text": ["items"]}], "container": true, "type": "dt_group"}, {"indent": 4, "type": "para", "text": ["Raises ", {"_hs_sc": true, "text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if any of the nodes or network boxes\n    are node children of this node.\n    Raises ", {"_hs_sc": true, "text": "", "value": "/hom/hou/PermissionError", "fallback_text": "hou.PermissionError", "fullpath": "/hom/hou/PermissionError", "scheme": "Hom", "type": "link"}, " if you do not have permission to read\n    the contents of this node."]}], "indent": 0, "text": [{"text": ["copyItemsToClipboard(self, items)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::copyItemsToClipboard"}, "type": "methods_item", "id": "copyItemsToClipboard"}, {"body": [{"indent": 4, "type": "para", "text": ["Given a sequence of child items (nodes, network boxes, sticky notes, etc),\n    save a file containing those items.  You can load this file using\n    ", {"_hs_sc": true, "fragment": "#loadItemsFromFile", "text": "", "value": "/hom/hou/Node#loadItemsFromFile", "fallback_text": "hou.Node.loadItemsFromFile", "fullpath": "/hom/hou/Node#loadItemsFromFile", "scheme": "Hom", "type": "link"}, "."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["A sequence of ", {"_hs_sc": true, "text": "", "value": "/hom/hou/NetworkMovableItem", "fallback_text": "hou.NetworkMovableItem", "fullpath": "/hom/hou/NetworkMovableItem", "scheme": "Hom", "type": "link"}, "s that are children of this\n        node."]}], "indent": 4, "type": "dt", "text": ["items"]}, {"body": [{"indent": 8, "type": "para", "text": ["The name of the file to write the contents to.  You can use any\n        extension for this file name."]}], "indent": 4, "type": "dt", "text": ["file_name"]}, {"body": [{"indent": 8, "type": "para", "text": ["Set to ", {"text": ["True"], "type": "code"}, " to save simplified definitions for HDAs into the file\n        along with the child nodes. Doing this allows the generated file to\n        be safely loaded into any houdini session, even if the assets used\n        in the file are not already loaded into the houdini session. Depending\n        on the use of the generated file, this information is often not\n        required and makes the files unnecessarily large."]}], "indent": 4, "type": "dt", "text": ["save_hda_fallbacks"]}], "container": true, "type": "dt_group"}, {"indent": 4, "type": "para", "text": ["Raises ", {"_hs_sc": true, "text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if any of the nodes or network boxes\n    are node children of this node, or if the file could not be written to.\n    Raises ", {"_hs_sc": true, "text": "", "value": "/hom/hou/PermissionError", "fallback_text": "hou.PermissionError", "fullpath": "/hom/hou/PermissionError", "scheme": "Hom", "type": "link"}, " if you do not have permission to read\n    the contents of this node."]}], "indent": 0, "text": [{"text": ["saveItemsToFile(self, items, file_name, save_hda_fallbacks = False)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::saveItemsToFile", "replaces": "/commands/opwrite"}, "type": "methods_item", "id": "saveItemsToFile"}, {"body": [{"indent": 4, "type": "para", "text": ["Combines separate lists of nods and network boxes into a single sequence,\n    and calls ", {"_hs_sc": true, "fragment": "#saveItemsToFile", "text": "", "value": "/hom/hou/Node#saveItemsToFile", "fallback_text": "hou.Node.saveItemsToFile", "fullpath": "/hom/hou/Node#saveItemsToFile", "scheme": "Hom", "type": "link"}, ". This method is provided for\n    backward compatibility. New code should call ", {"text": ["saveItemsToFile"], "type": "code"}, " directly."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["A sequence of ", {"_hs_sc": true, "text": "", "value": "/hom/hou/Node", "fallback_text": "hou.Node", "fullpath": "/hom/hou/Node", "scheme": "Hom", "type": "link"}, "s that are children of this node."]}], "indent": 4, "type": "dt", "text": ["nodes"]}, {"body": [{"indent": 8, "type": "para", "text": ["A sequence of ", {"_hs_sc": true, "text": "", "value": "/hom/hou/NetworkBox", "fallback_text": "hou.NetworkBox", "fullpath": "/hom/hou/NetworkBox", "scheme": "Hom", "type": "link"}, "es that are contained in this node.\n        Note that the contents of the network boxes are not automatically\n        saved, so it is up to you to put them in the list of nodes."]}], "indent": 4, "type": "dt", "text": ["network_boxes"]}], "container": true, "type": "dt_group"}], "indent": 0, "text": [{"text": ["saveChildrenToFile(self, nodes, network_boxes, file_name)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::saveChildrenToFile", "replaces": "/commands/opwrite"}, "type": "methods_item", "id": "saveChildrenToFile"}, {"body": [{"indent": 4, "type": "para", "text": ["Load the contents of a file saved with ", {"_hs_sc": true, "fragment": "#saveChildrenToFile", "text": "", "value": "/hom/hou/Node#saveChildrenToFile", "fallback_text": "hou.Node.saveChildrenToFile", "fullpath": "/hom/hou/Node#saveChildrenToFile", "scheme": "Hom", "type": "link"}, "\n    into the contents of this node."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"_hs_sc": true, "text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if the file does not exist or it is not\n    the correct type of file.  Raises ", {"_hs_sc": true, "text": "", "value": "/hom/hou/PermissionError", "fallback_text": "hou.PermissionError", "fullpath": "/hom/hou/PermissionError", "scheme": "Hom", "type": "link"}, " if this\n    node is a locked instance of a digital asset.  Raises ", {"_hs_sc": true, "text": "", "value": "/hom/hou/LoadWarning", "fallback_text": "hou.LoadWarning", "fullpath": "/hom/hou/LoadWarning", "scheme": "Hom", "type": "link"}, "\n    if the load succeeds but with warnings and ", {"text": ["ignore_load_warnings"], "type": "code"}, " is\n    ", {"text": ["False"], "type": "code"}, "."]}], "indent": 0, "text": [{"text": ["loadItemsFromFile(self, file_name, ignore_load_warnings=False)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::loadChildrenFromFile", "replaces": "/commands/opread"}, "type": "methods_item", "id": "loadItemsFromFile"}, {"body": [{"indent": 4, "type": "para", "text": ["Calls ", {"_hs_sc": true, "fragment": "#loadItemsFromFile", "text": "", "value": "/hom/hou/Node#loadItemsFromFile", "fallback_text": "hou.Node.loadItemsFromFile", "fullpath": "/hom/hou/Node#loadItemsFromFile", "scheme": "Hom", "type": "link"}, ". Provided for backward\n    compatibility. New code should call ", {"text": ["loadItemsFromFile"], "type": "code"}, " directly."]}], "indent": 0, "text": [{"text": ["loadChildrenFromFile(self, file_name, ignore_load_warnings=False)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::loadChildrenFromFile", "replaces": "/commands/opread"}, "type": "methods_item", "id": "loadChildrenFromFile"}, {"body": [{"indent": 4, "type": "para", "text": ["Load the contents of a file saved with ", {"_hs_sc": true, "fragment": "#copyItemsToClipboard", "text": "", "value": "/hom/hou/Node#copyItemsToClipboard", "fallback_text": "hou.Node.copyItemsToClipboard", "fullpath": "/hom/hou/Node#copyItemsToClipboard", "scheme": "Hom", "type": "link"}, "\n    into the contents of this node. If the ", {"text": ["position"], "type": "code"}, " parameter is given as a\n    tuple of two float values (or equivalent, like a ", {"_hs_sc": true, "text": "", "value": "/hom/hou/Vector2", "fallback_text": "hou.Vector2", "fullpath": "/hom/hou/Vector2", "scheme": "Hom", "type": "link"}, "), the\n    pasted items are moved such that they are centered around the provided\n    position."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"_hs_sc": true, "text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if this node is not a network, or if\n    there are errors loading the items from the clipboard. Raises\n    ", {"_hs_sc": true, "text": "", "value": "/hom/hou/PermissionError", "fallback_text": "hou.PermissionError", "fullpath": "/hom/hou/PermissionError", "scheme": "Hom", "type": "link"}, " if this node is a locked instance of a\n    digital asset."]}], "indent": 0, "text": [{"text": ["pasteItemsFromClipboard(self, position = None)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::pasteItemsFromClipboard"}, "type": "methods_item", "id": "pasteItemsFromClipboard"}, {"body": [{"indent": 4, "type": "para", "text": ["Prints the Python code necessary to recreate a node."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["Do not set values if they are the parameter\u2019s default.  Applies to the\n        contents of the node if either recurse or save_box_contents is True."]}], "indent": 4, "type": "dt", "text": [{"text": ["brief"], "type": "code"}]}, {"body": [{"indent": 8, "type": "para", "text": ["Recursively apply to the entire operator hierarchy."]}], "indent": 4, "type": "dt", "text": [{"text": ["recurse"], "type": "code"}]}, {"body": [{"indent": 8, "type": "para", "text": ["Script the contents of the node."]}], "indent": 4, "type": "dt", "text": [{"text": ["save_box_contents"], "type": "code"}]}, {"body": [{"indent": 8, "type": "para", "text": ["Only output channels.  Applies to the contents of the node if either\n        recurse or save_box_contents is True."]}], "indent": 4, "type": "dt", "text": [{"text": ["save_channels_only"], "type": "code"}]}, {"body": [{"indent": 8, "type": "para", "text": ["Generate a creation script for the node.  If set to False, the\n        generated script assumes that the network box already exists.  When set\n        to True, the script will begin by creating the network box."]}], "indent": 4, "type": "dt", "text": [{"text": ["save_creation_commands"], "type": "code"}]}, {"body": [{"indent": 8, "type": "para", "text": ["Output channel and key times in samples (frames) instead of seconds.\n        Applies to the contents of the node if either recurse or\n        save_box_contents is True."]}], "indent": 4, "type": "dt", "text": [{"text": ["save_keys_in_frames"], "type": "code"}]}, {"body": [{"indent": 8, "type": "para", "text": ["Evaluate parameters, saving their values instead of the expressions.\n        Applies to the contents of the node if either recurse or\n        save_box_contents is True."]}], "indent": 4, "type": "dt", "text": [{"text": ["save_parm_values_only"], "type": "code"}]}, {"body": [{"indent": 8, "type": "para", "text": ["Save spare parameters as well.  When save_creation_commands is True,\n        commands for creating spare parameters will also be output.  Applies to\n        the contents of the node if either recurse or save_box_contents is\n        True."]}], "indent": 4, "type": "dt", "text": [{"text": ["save_spare_parms"], "type": "code"}]}, {"body": [{"indent": 8, "type": "para", "text": ["If a function_name is specified, the output will be wrapped in a Python\n        function."]}], "indent": 4, "type": "dt", "text": [{"text": ["function_name"], "type": "code"}]}], "container": true, "type": "dt_group"}], "indent": 0, "text": [{"text": ["asCode(self, brief=False, recurse=False, save_channels_only=False, save_creation_commands=True, save_keys_in_frames=False, save_outgoing_wires=False, save_parm_values_only=False, save_spare_parms=True, function_name=None)"], "type": "code"}, "  \u2192 ", {"text": ["str"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::asCode", "replaces": "/commands/opscript"}, "type": "methods_item", "id": "asCode"}], "container": true, "role": "item_group", "type": "methods_item_group"}], "indent": 0, "level": 2, "text": ["Serialization"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Implements ", {"text": ["=="], "type": "code"}, " between ", {"text": ["Node"], "type": "code"}, " objects."]}, {"indent": 4, "type": "para", "text": ["For example,  hou.root() == hou.node(\"/\") will return ", {"text": ["True"], "type": "code"}, "."]}, {"indent": 4, "type": "para", "text": ["There can be multiple Python ", {"text": ["Node"], "type": "code"}, " objects for the same Houdini node.\n    Two identical calls to ", {"text": ["hou.node()"], "type": "code"}, " will return different Python ", {"text": ["Node"], "type": "code"}, "\n    objects, with each representing the same Houdini node. Comparing these nodes\n    using ", {"text": ["=="], "type": "code"}, " (which calls ", {"text": ["__eq__"], "type": "code"}, ") will return ", {"text": ["True"], "type": "code"}, ", while comparing them\n    using ", {"text": ["is"], "type": "code"}, " (the object identity test) will return ", {"text": ["False"], "type": "code"}, "."]}], "indent": 0, "text": [{"text": ["__eq__(self, node)"], "type": "code"}, "  \u2192 ", {"text": ["bool"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::operator==(HOM_Node*)"}, "type": "methods_item", "id": "__eq__"}, {"body": [{"indent": 4, "type": "para", "text": ["Implements ", {"text": ["!="], "type": "code"}, " between ", {"text": ["Node"], "type": "code"}, " objects. See ", {"text": ["__eq__()"], "type": "code"}, "."]}], "indent": 0, "text": [{"text": ["__ne__(self, node)"], "type": "code"}, "  \u2192 ", {"text": ["bool"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::operator!=(HOM_Node*)"}, "type": "methods_item", "id": "__ne__"}], "container": true, "role": "item_group", "type": "methods_item_group"}], "indent": 0, "level": 2, "text": ["Operators"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Register a Python callback that Houdini will call whenever a particular\n    action, or event, occurs on this node. Callbacks only persist for the\n    current session; they will not be saved to .hip files, for example."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["A sequence of ", {"_hs_sc": true, "text": "", "value": "/hom/hou/nodeEventType", "fallback_text": "hou.nodeEventType", "fullpath": "/hom/hou/nodeEventType", "scheme": "Hom", "type": "link"}, " enumeration values describing\n        the event types that will cause the callback to be invoked.  See\n        below for the meanings of the different event types."]}], "indent": 4, "type": "dt", "text": [{"text": ["event_types"], "type": "code"}]}, {"body": [{"indent": 8, "type": "para", "text": ["A callable Python object, such as a function or bound method, that\n        Houdini will invoke whenever one of the desired event types occurs\n        on this node."]}, {"indent": 8, "type": "para", "text": ["The callback will be invoked with different keyword arguments depending\n        on the event type, so the callback should always use a ", {"text": ["**kwargs"], "type": "code"}, "\n        parameter (see the example below).  Keyword arguments named\n        ", {"text": ["event_type"], "type": "code"}, " and ", {"text": ["node"], "type": "code"}, " are always passed to the callback, and contain\n        the ", {"_hs_sc": true, "text": "", "value": "/hom/hou/nodeEventType", "fallback_text": "hou.nodeEventType", "fullpath": "/hom/hou/nodeEventType", "scheme": "Hom", "type": "link"}, " enumerated value corresponding to the event\n        type and the ", {"_hs_sc": true, "text": "", "value": "/hom/hou/Node", "fallback_text": "hou.Node", "fullpath": "/hom/hou/Node", "scheme": "Hom", "type": "link"}, " object, respectively."]}], "indent": 4, "type": "dt", "text": [{"text": ["callback"], "type": "code"}]}], "container": true, "type": "dt_group"}, {"indent": 4, "type": "para", "text": ["The following table describes the meaning of the ", {"_hs_sc": true, "text": "", "value": "/hom/hou/nodeEventType", "fallback_text": "hou.nodeEventType", "fullpath": "/hom/hou/nodeEventType", "scheme": "Hom", "type": "link"}, "\n    enumeration values:"]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["This node is about to be deleted.  The deletion cannot be canceled."]}], "indent": 4, "type": "dt", "text": [{"text": ["BeingDeleted"], "type": "code"}]}, {"body": [{"indent": 8, "type": "para", "text": ["This node was renamed.  You can get the new name with\n        ", {"text": ["kwargs[\"node\"].name()"], "type": "code"}]}], "indent": 4, "type": "dt", "text": [{"text": ["NameChanged"], "type": "code"}]}, {"body": [{"indent": 8, "type": "para", "text": ["One of the node\u2019s flags, such as the display flag, was changed."]}], "indent": 4, "type": "dt", "text": [{"text": ["FlagChanged"], "type": "code"}]}, {"body": [{"indent": 8, "type": "para", "text": ["The appearance of this node changed in some way.  For example, any of\n        the following can generate an appearance change event: the node\u2019s color\n        changed, an error flag changed, the node was selected, the node was\n        locked, the node was deleted, etc.\n        ", {"text": ["kwargs[\"change_type\"]"], "type": "code"}, " contains the ", {"_hs_sc": true, "text": "", "value": "/hom/hou/appearanceChangeType", "fallback_text": "hou.appearanceChangeType", "fullpath": "/hom/hou/appearanceChangeType", "scheme": "Hom", "type": "link"}, "\n        corresponding to the specific change."]}], "indent": 4, "type": "dt", "text": [{"text": ["AppearanceChanged"], "type": "code"}]}, {"body": [{"indent": 8, "type": "para", "text": ["The node\u2019s position in the network editor pane changed.  You can\n        find the new position with ", {"text": ["kwargs[\"node\"].position()"], "type": "code"}, "."]}], "indent": 4, "type": "dt", "text": [{"text": ["PositionChanged"], "type": "code"}]}, {"body": [{"indent": 8, "type": "para", "text": ["One of the node\u2019s inputs was wired in or unwired.  You can find the\n        input connector index with ", {"text": ["kwargs[\"input_index\"]"], "type": "code"}, "."]}], "indent": 4, "type": "dt", "text": [{"text": ["InputRewired"], "type": "code"}]}], "container": true, "type": "dt_group"}, {"indent": 4, "type": "para", "text": [{"text": ["InputDataChanged"], "type": "code"}, ":\n    The data on one of the node\u2019s dependencies has changed. In the case of\n    a parameter change, this notification will not be sent."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["A parameter in the node changed.  ", {"text": ["kwargs[\"parm_tuple\"]"], "type": "code"}, " contains\n        the ", {"_hs_sc": true, "text": "", "value": "/hom/hou/ParmTuple", "fallback_text": "hou.ParmTuple", "fullpath": "/hom/hou/ParmTuple", "scheme": "Hom", "type": "link"}, " corresponding to the changed parameter."]}, {"indent": 8, "type": "para", "text": ["Note that there are cases where Houdini will send out notifications\n        that all parms have changed.  In these circumstances,\n        ", {"text": ["kwargs[\"parm_tuple\"]"], "type": "code"}, " will be ", {"text": ["None"], "type": "code"}, "."]}], "indent": 4, "type": "dt", "text": [{"text": ["ParmTupleChanged"], "type": "code"}]}, {"body": [{"indent": 8, "type": "para", "text": ["The set of selected nodes for this network changed.  You can get the\n        selected nodes with ", {"text": ["kwargs[\"node\"].selectedChildren()"], "type": "code"}, "."]}], "indent": 4, "type": "dt", "text": [{"text": ["ChildSelectionChanged"], "type": "code"}]}, {"body": [{"indent": 8, "type": "para", "text": ["A node was created inside this network.  ", {"text": ["kwargs[\"child_node\"]"], "type": "code"}, " contains\n        the ", {"_hs_sc": true, "text": "", "value": "/hom/hou/Node", "fallback_text": "hou.Node", "fullpath": "/hom/hou/Node", "scheme": "Hom", "type": "link"}, " that was created."]}], "indent": 4, "type": "dt", "text": [{"text": ["ChildCreated"], "type": "code"}]}, {"body": [{"indent": 8, "type": "para", "text": ["A node inside this network is about to be deleted.\n        ", {"text": ["kwargs[\"child_node\"]"], "type": "code"}, " contains the ", {"_hs_sc": true, "text": "", "value": "/hom/hou/Node", "fallback_text": "hou.Node", "fullpath": "/hom/hou/Node", "scheme": "Hom", "type": "link"}, " that will be\n        deleted."]}], "indent": 4, "type": "dt", "text": [{"text": ["ChildDeleted"], "type": "code"}]}, {"body": [{"indent": 8, "type": "para", "text": ["The current node, display node, or render node inside this network\n        was changed.  ", {"text": ["kwargs[\"child_node\"]"], "type": "code"}, " contains the newly selected child\n        ", {"_hs_sc": true, "text": "", "value": "/hom/hou/Node", "fallback_text": "hou.Node", "fullpath": "/hom/hou/Node", "scheme": "Hom", "type": "link"}, "."]}], "indent": 4, "type": "dt", "text": [{"text": ["ChildSwitched"], "type": "code"}]}, {"body": [{"indent": 8, "type": "para", "text": ["The node had a spare parm templates modified, added or removed. Note\n        that this event is also sent out for any non-spare parm template\n        modifications if the node has any spare parms."]}], "indent": 4, "type": "dt", "text": [{"text": ["SpareParmTemplatesChanged"], "type": "code"}]}], "container": true, "type": "dt_group"}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["If the callback has already been added for this node, this method\n        simply updates the set of event types for the callback.  For example,\n        suppose you had added a callback for NameChanged and FlagChanged\n        events and you add the same callback for NameChanged and\n        ParmTupleChanged events.  If a NameChanged event occurs, Houdini will\n        run the callback once, not twice.  Internally, Houdini updates the\n        set of event types for your callback to NameChanged, FlagChanged, and\n        ParmTupleChanged events."]}], "indent": 4, "role": "item", "type": "note"}], "container": true, "role": "item_group", "type": "note_group"}, {"indent": 4, "type": "para", "text": ["The following example shows how you can monitor all objects in Houdini\n    for parameter changes:"]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    event_types = (\n        hou.nodeEventType.ParmTupleChanged,\n        hou.nodeEventType.ChildCreated)\n\n    def setUpCallback(node):\n        node.addEventCallback(event_types, onNodeChange)\n\n    def onNodeChange(**kwargs):\n        if kwargs[\"event_type\"] == hou.nodeEventType.ParmTupleChanged:\n            # If all parameters effectively changed, kwargs[\"parm_tuple\"] will\n            # be None.  We're only interested when individual parameters\n            # change.\n            if kwargs[\"parm_tuple\"] is not None:\n                onParmTupleChange(kwargs[\"parm_tuple\"])\n        elif kwargs[\"event_type\"] == hou.nodeEventType.ChildCreated:\n            setUpCallback(kwargs[\"child_node\"])\n\n    def onParmTupleChange(parm_tuple):\n        # Add your code here to respond to a parameter change.\n        print \"Parameter changed:\", parm_tuple\n\n    def allSubChildren(node):\n        yield node\n        for child_node in node.children():\n            for n in allSubChildren(child_node):\n                yield n\n\n    # Set up node callbacks for all existing nodes so we're notified when any\n    # of their children get created.\n    for node in allSubChildren(hou.node(\"/\")):\n        setUpCallback(node)\n    "]}, {"indent": 4, "type": "para", "text": ["If many parameters are changing, you may want to defer processing the\n    updates until they're all finished.  The following code provides a\n    new version of onParmTupleChange that queues parameter changes:"]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    import hdefereval\n\n    _changed_parm_tuples = []\n\n    def onParmTupleChange(parm_tuple):\n        _changed_parm_tuples.append(parm_tuple)\n        if len(_changed_parm_tuples) == 1:\n            hdefereval.executeDeferred(onProcessParmTupleChanges)\n\n    def onProcessParmTupleChanges():\n        # Add your code here to respond to deferred parameter changes.\n        for parm_tuple in _changed_parm_tuples:\n            print \"Parameter changed:\", parm_tuple\n        _changed_parm_tuples[:] = []\n    "]}, {"indent": 4, "type": "para", "text": ["See also ", {"_hs_sc": true, "fragment": "#removeEventCallback", "text": "", "value": "/hom/hou/Node#removeEventCallback", "fallback_text": "hou.Node.removeEventCallback", "fullpath": "/hom/hou/Node#removeEventCallback", "scheme": "Hom", "type": "link"}, " and\n    ", {"_hs_sc": true, "fragment": "#removeAllEventCallbacks", "text": "", "value": "/hom/hou/Node#removeAllEventCallbacks", "fallback_text": "hou.Node.removeAllEventCallbacks", "fullpath": "/hom/hou/Node#removeAllEventCallbacks", "scheme": "Hom", "type": "link"}, "."]}], "indent": 0, "text": [{"text": ["addEventCallback(self, event_types, callback)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::addEventCallback"}, "type": "methods_item", "id": "addEventCallback"}, {"body": [{"indent": 4, "type": "para", "text": ["Given a callback that was previously added on this node and a sequence\n    of ", {"_hs_sc": true, "text": "", "value": "/hom/hou/nodeEventType", "fallback_text": "hou.nodeEventType", "fullpath": "/hom/hou/nodeEventType", "scheme": "Hom", "type": "link"}, " enumerated values, remove those event types from\n    the set of event types for the callback.  If the remaining set of event\n    types is empty, the callback will be removed entirely from this node."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"_hs_sc": true, "text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if the callback had not been previously\n    added."]}, {"indent": 4, "type": "para", "text": ["See ", {"_hs_sc": true, "fragment": "#addEventCallback", "text": "", "value": "/hom/hou/Node#addEventCallback", "fallback_text": "hou.Node.addEventCallback", "fullpath": "/hom/hou/Node#addEventCallback", "scheme": "Hom", "type": "link"}, " for more information."]}], "indent": 0, "text": [{"text": ["removeEventCallback(self, event_types, callback)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::removeEventCallback"}, "type": "methods_item", "id": "removeEventCallback"}, {"body": [{"indent": 4, "type": "para", "text": ["Remove all event callbacks for all event types from this node."]}, {"indent": 4, "type": "para", "text": ["See ", {"_hs_sc": true, "fragment": "#addEventCallback", "text": "", "value": "/hom/hou/Node#addEventCallback", "fallback_text": "hou.Node.addEventCallback", "fullpath": "/hom/hou/Node#addEventCallback", "scheme": "Hom", "type": "link"}, " for more information."]}], "indent": 0, "text": [{"text": ["removeAllEventCallbacks(self)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::removeAllEventCallbacks"}, "type": "methods_item", "id": "removeAllEventCallbacks"}], "container": true, "role": "item_group", "type": "methods_item_group"}], "indent": 0, "level": 2, "text": ["Callbacks"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Add/set a named string on this node instance."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["A unique name (key) for the user-defined data.  By using different\n        names, you can attach multiple pieces of user-defined data to a node."]}], "indent": 4, "type": "dt", "text": [{"text": ["name"], "type": "code"}]}, {"body": [{"indent": 8, "type": "para", "text": ["The string to store."]}], "indent": 4, "type": "dt", "text": [{"text": ["value"], "type": "code"}]}], "container": true, "type": "dt_group"}, {"indent": 4, "type": "para", "text": ["This name/value pair is stored with the hip file and is included in the\n    output from ", {"_hs_sc": true, "text": "", "value": "/commands/opscript", "fallback_text": "opscript", "fullpath": "/commands/opscript", "scheme": "Cmd", "type": "link"}, " and ", {"_hs_sc": true, "fragment": "#asCode", "text": "", "value": "/hom/hou/Node#asCode", "fallback_text": "hou.Node.asCode", "fullpath": "/hom/hou/Node#asCode", "scheme": "Hom", "type": "link"}, "."]}, {"indent": 4, "type": "para", "text": ["The following example illustrates how to set, access, and delete\n    user-defined data:"]}, {"lang": "pycon", "indent": 4, "type": "pre", "text": ["\n    >>> n = hou.node(\"/obj\").createNode(\"geo\")\n    >>> n.setUserData(\"my data\", \"my data value\")\n    >>> n.userData(\"my data\")\n    'my data value'\n    >>> n.userDataDict()\n    {'my data': 'my data value'}\n    >>> n.destroyUserData(\"my data\")\n    >>> n.userDataDict()\n    {}\n    >>> print n.userData(\"my data\")\n    None\n    "]}, {"indent": 4, "type": "para", "text": ["See ", {"_hs_sc": true, "text": ["per-node user-defined data"], "value": "/hom/nodeuserdata", "fullpath": "/hom/nodeuserdata", "scheme": "Hom", "type": "link"}, " for more information\n    and examples."]}], "indent": 0, "text": [{"text": ["setUserData(self, name, value)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::setUserData"}, "type": "methods_item", "id": "setUserData"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a dictionary containing all the user-defined name/string pairs\n    for this node."]}, {"indent": 4, "type": "para", "text": ["See ", {"_hs_sc": true, "fragment": "#setUserData", "text": "", "value": "/hom/hou/Node#setUserData", "fallback_text": "hou.Node.setUserData", "fullpath": "/hom/hou/Node#setUserData", "scheme": "Hom", "type": "link"}, " for more information."]}], "indent": 0, "text": [{"text": ["userDataDict(self, name)"], "type": "code"}, "  \u2192 ", {"text": ["dict"], "type": "code"}, " of ", {"text": ["str"], "type": "code"}, " to ", {"text": ["str"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::userDataDict"}, "type": "methods_item", "id": "userDataDict"}, {"body": [{"indent": 4, "type": "para", "text": ["Return the user-defined data with this name, or ", {"text": ["None"], "type": "code"}, " if no data with this\n    name exists."]}, {"indent": 4, "type": "para", "text": ["See ", {"_hs_sc": true, "fragment": "#setUserData", "text": "", "value": "/hom/hou/Node#setUserData", "fallback_text": "hou.Node.setUserData", "fullpath": "/hom/hou/Node#setUserData", "scheme": "Hom", "type": "link"}, " for more information."]}, {"indent": 4, "type": "para", "text": ["This method can be implemented as follows:"]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    def userData(self, name):\n        return self.userDataDict().get(name)\n    "]}], "indent": 0, "text": [{"text": ["userData(self, name)"], "type": "code"}, "  \u2192 ", {"text": ["str"], "type": "code"}, " or ", {"text": ["None"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::userData"}, "type": "methods_item", "id": "userData"}, {"body": [{"indent": 4, "type": "para", "text": ["Remove the user-defined data with this name."]}, {"indent": 4, "type": "para", "text": ["See ", {"_hs_sc": true, "fragment": "#setUserData", "text": "", "value": "/hom/hou/Node#setUserData", "fallback_text": "hou.Node.setUserData", "fullpath": "/hom/hou/Node#setUserData", "scheme": "Hom", "type": "link"}, " for more information."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"_hs_sc": true, "text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if no user data with this name exists."]}], "indent": 0, "text": [{"text": ["destroyUserData(self, name)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::destroyUserData"}, "type": "methods_item", "id": "destroyUserData"}, {"body": [{"indent": 4, "type": "para", "text": ["Add/set a named value on this node instance.  Unlike ", {"text": ["setUserData"], "type": "code"}, ",\n    values set using this method are not saved with the hip file."]}, {"indent": 4, "type": "para", "text": [{"text": ["name"], "type": "code"}, ":\n    A unique name (key) for the user-defined data.  By using different\n    names, you can attach multiple pieces of user-defined data to a node.\n    ", {"text": ["value"], "type": "code"}, ":\n    The value to store.  Unlike ", {"text": ["setUserData"], "type": "code"}, ", this value may be any Python\n    object."]}, {"indent": 4, "type": "para", "text": ["This name/value pair is not stored with the hip file.  It is useful for\n    nodes implemented in Python that want to save temporary values between\n    cooks, to avoid recomputing them on subsequent cooks."]}, {"indent": 4, "type": "para", "text": ["The following example illustrates how to set, access, and delete\n    cached user-defined data:"]}, {"lang": "pycon", "indent": 4, "type": "pre", "text": ["\n    >>> n = hou.node(\"/obj\").createNode(\"geo\")\n    >>> n.setCachedUserData(\"my data\", [1, 2, {\"a\": \"b\", \"c\": \"d\"}])\n    >>> n.cachedUserData(\"my data\")\n    [1, 2, {'a': 'b', 'c': 'd'}]\n    >>> n.cachedUserDataDict()\n    {'my data': [1, 2, {'a': 'b', 'c': 'd'}]}\n    >>> n.destroyCachedUserData(\"my data\")\n    >>> n.cachedUserDataDict()\n    {}\n    >>> print n.cachedUserData(\"my data\")\n    None\n    "]}, {"indent": 4, "type": "para", "text": ["See ", {"_hs_sc": true, "text": ["per-node user-defined data"], "value": "/hom/nodeuserdata", "fullpath": "/hom/nodeuserdata", "scheme": "Hom", "type": "link"}, " for more information\n    and examples."]}], "indent": 0, "text": [{"text": ["setCachedUserData(self, name, value)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::setCachedUserData"}, "type": "methods_item", "id": "setCachedUserData"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a dictionary containing all the user-defined name/string pairs\n    for this node."]}, {"indent": 4, "type": "para", "text": ["See ", {"_hs_sc": true, "fragment": "#setCachedUserData", "text": "", "value": "/hom/hou/Node#setCachedUserData", "fallback_text": "hou.Node.setCachedUserData", "fullpath": "/hom/hou/Node#setCachedUserData", "scheme": "Hom", "type": "link"}, " for more information."]}], "indent": 0, "text": [{"text": ["cachedUserDataDict(self, name)"], "type": "code"}, "  \u2192 ", {"text": ["dict"], "type": "code"}, " of ", {"text": ["str"], "type": "code"}, " to ", {"text": ["str"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::cachedUserDataDict"}, "type": "methods_item", "id": "cachedUserDataDict"}, {"body": [{"indent": 4, "type": "para", "text": ["Return the user-defined cached data with this name, or ", {"text": ["None"], "type": "code"}, " if no data\n    with this name exists."]}, {"indent": 4, "type": "para", "text": ["See ", {"_hs_sc": true, "fragment": "#setCachedUserData", "text": "", "value": "/hom/hou/Node#setCachedUserData", "fallback_text": "hou.Node.setCachedUserData", "fullpath": "/hom/hou/Node#setCachedUserData", "scheme": "Hom", "type": "link"}, " for more information."]}, {"indent": 4, "type": "para", "text": ["This method can be implemented as follows:"]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    def cachedUserData(self, name):\n        return self.cachedUserDataDict().get(name)\n    "]}, {"indent": 4, "type": "para", "text": ["Note that ", {"text": ["None"], "type": "code"}, " is a valid value for a key, so the most reliable way to\n    check if a key is valid is to check if it is in the result of\n    ", {"text": ["cachedUserDataDict"], "type": "code"}, ":"]}, {"lang": "pycon", "indent": 4, "type": "pre", "text": ["\n    >>> n = hou.node(\"/obj\").createNode(\"geo\")\n    >>> n.cachedUserDataDict()\n    {}\n    >>> print n.cachedUserData(\"foo\")\n    None\n    >>> \"foo\" in n.cachedUserDataDict()\n    False\n    >>> n.setCachedUserData(\"foo\", None)\n    >>> n.cachedUserDataDict()\n    {'foo': None}\n    >>> print n.cachedUserData(\"foo\")\n    None\n    >>> \"foo\" in n.cachedUserDataDict()\n    True\n    "]}], "indent": 0, "text": [{"text": ["cachedUserData(self, name)"], "type": "code"}, "  \u2192 ", {"text": ["str"], "type": "code"}, " or ", {"text": ["None"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::cachedUserData"}, "type": "methods_item", "id": "cachedUserData"}, {"body": [{"indent": 4, "type": "para", "text": ["Remove the user-defined cached data with this name."]}, {"indent": 4, "type": "para", "text": ["See ", {"_hs_sc": true, "fragment": "#setCachedUserData", "text": "", "value": "/hom/hou/Node#setCachedUserData", "fallback_text": "hou.Node.setCachedUserData", "fullpath": "/hom/hou/Node#setCachedUserData", "scheme": "Hom", "type": "link"}, " for more information."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"_hs_sc": true, "text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if no user data with this name exists."]}], "indent": 0, "text": [{"text": ["destroyCachedUserData(self, name)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::destroyCachedUserData"}, "type": "methods_item", "id": "destroyCachedUserData"}], "container": true, "role": "item_group", "type": "methods_item_group"}], "indent": 0, "level": 2, "text": ["User data"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Return the simulation defined by this DOP network node.  This raises\n    an exception if this is not a dop network."]}], "indent": 0, "text": [{"text": ["simulation(self)"], "type": "code"}, "  \u2192 ", {"_hs_sc": true, "text": "", "value": "/hom/hou/DopSimulation", "fallback_text": "hou.DopSimulation", "fullpath": "/hom/hou/DopSimulation", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_DopNetNode::simulation"}, "type": "methods_item", "id": "simulation"}, {"body": [{"indent": 4, "type": "para", "text": ["Given a ", {"_hs_sc": true, "text": "", "value": "/hom/hou/DopObject", "fallback_text": "hou.DopObject", "fullpath": "/hom/hou/DopObject", "scheme": "Hom", "type": "link"}, ", return a tuple of DOP nodes that processed\n    that object.  This raises an exception if this is not a dopnetwork."]}], "indent": 0, "text": [{"text": ["findNodesThatProcessedObject(self, dop_object)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"_hs_sc": true, "text": "", "value": "/hom/hou/DopNode", "fallback_text": "hou.DopNode", "fullpath": "/hom/hou/DopNode", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_DopNetNode::findNodesThatProcessedObject", "replaces": "/expressions/dopnodeobjs"}, "type": "methods_item", "id": "findNodesThatProcessedObject"}, {"body": [{"indent": 4, "type": "para", "text": ["Synchronize the node from the specified version to the current version of\n    its HDA definition. See also ", {"_hs_sc": true, "fragment": "#version", "text": "", "value": "/hom/hou/HDADefinition#version", "fallback_text": "hou.HDADefinition.version", "fullpath": "/hom/hou/HDADefinition#version", "scheme": "Hom", "type": "link"}, "."]}], "indent": 0, "text": [{"text": ["syncNodeVersionIfNeeded(self, from_version)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::syncNodeVersionIfNeeded"}, "type": "methods_item", "id": "syncNodeVersionIfNeeded"}], "container": true, "role": "item_group", "type": "methods_item_group"}], "indent": 0, "level": 2, "text": ["Dynamics"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Return True if the specified flag is readable and False otherwise."]}, {"indent": 4, "type": "para", "text": [{"text": ["flag"], "type": "code"}, " must be a ", {"_hs_sc": true, "text": "", "value": "/hom/hou/nodeFlag", "fallback_text": "hou.nodeFlag", "fullpath": "/hom/hou/nodeFlag", "scheme": "Hom", "type": "link"}, " value. "]}], "indent": 0, "text": [{"text": ["isFlagReadable(self, flag)"], "type": "code"}, "  \u2192 ", {"text": ["bool"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::isFlagReadable"}, "type": "methods_item", "id": "isFlagReadable"}, {"body": [{"indent": 4, "type": "para", "text": ["Return True if the specified flag is writable and False otherwise."]}, {"indent": 4, "type": "para", "text": [{"text": ["flag"], "type": "code"}, " must be a ", {"_hs_sc": true, "text": "", "value": "/hom/hou/nodeFlag", "fallback_text": "hou.nodeFlag", "fullpath": "/hom/hou/nodeFlag", "scheme": "Hom", "type": "link"}, " value."]}], "indent": 0, "text": [{"text": ["isFlagWritable(self, flag)"], "type": "code"}, "  \u2192 ", {"text": ["bool"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::isFlagWritable"}, "type": "methods_item", "id": "isFlagWritable"}, {"body": [{"indent": 4, "type": "para", "text": ["Returns the value of the specific flag."]}, {"indent": 4, "type": "para", "text": [{"text": ["flag"], "type": "code"}, " must be a ", {"_hs_sc": true, "text": "", "value": "/hom/hou/nodeFlag", "fallback_text": "hou.nodeFlag", "fullpath": "/hom/hou/nodeFlag", "scheme": "Hom", "type": "link"}, " value. "]}], "indent": 0, "text": [{"text": ["isGenericFlagSet(self, flag)"], "type": "code"}, "  \u2192 ", {"text": ["bool"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::isGenericFlagSet"}, "type": "methods_item", "id": "isGenericFlagSet"}, {"body": [{"indent": 4, "type": "para", "text": ["Sets the value of the specified flag based on the ", {"text": ["bool"], "type": "code"}, " ", {"text": ["value"], "type": "code"}, " argument."]}, {"indent": 4, "type": "para", "text": [{"text": ["flag"], "type": "code"}, " must be a ", {"_hs_sc": true, "text": "", "value": "/hom/hou/nodeFlag", "fallback_text": "hou.nodeFlag", "fullpath": "/hom/hou/nodeFlag", "scheme": "Hom", "type": "link"}, " value. "]}], "indent": 0, "text": [{"text": ["setGenericFlag(self, flag, value)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Node::setGenericFlag"}, "type": "methods_item", "id": "setGenericFlag"}], "container": true, "role": "item_group", "type": "methods_item_group"}], "indent": 0, "level": 2, "text": ["Flags"], "container": true, "type": "h", "id": null}], "indent": 0, "level": 1, "text": "Methods", "role": "section", "container": true, "type": "methods_section", "id": "methods"}], "summary": ["The base class for all nodes in Houdini (objects, SOPs, COPs, etc.)  An instance of this class corresponds to exactly one instance of a node in Houdini."], "type": "root", "attrs": {"cppname": "HOM_Node", "type": "homclass", "superclass": "hou.NetworkMovableItem", "group": "nodes"}, "title": [{"text": "hou.", "type": "supertitle"}, "Node"]}